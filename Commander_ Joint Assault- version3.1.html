<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<title>æŒ‡æŒ¥å®˜ï¼šé™†ç©ºæ”»åŠ¿ [AIè¿›åŒ–ç‰ˆ v3.0]</title>
<style>
  :root{
    --term-green:#4af626;
    --term-amber:#ffb000;
    --term-red:#ff3333;
    --term-bg:#0a0a0a;
    /* åƒç´ é£UIå˜é‡ */
    --pixel-light: #888;
    --pixel-face: #555;
    --pixel-shadow: #222;
    --pixel-dark: #000;
  }
  *{ box-sizing:border-box; touch-action:none; user-select:none; -webkit-user-select:none; }
  body,html{
    margin:0; padding:0; width:100%; height:100%; overflow:hidden;
    background:#000; font-family:'Courier New', Courier, monospace; font-weight:bold; color:var(--term-green);
    text-shadow: 0 0 6px rgba(74,246,38,0.25), 2px 2px 0 rgba(0,0,0,0.8);
    letter-spacing:0.5px;
  }
  #gameContainer{ position:relative; width:100%; height:100%; display:flex; justify-content:center; align-items:center; background:#000; }
  #crt-overlay{
    position:absolute; inset:0; pointer-events:none; z-index:900;
    background:
      linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.28) 50%),
      linear-gradient(90deg, rgba(255,0,0,0.07), rgba(0,255,0,0.025), rgba(0,0,255,0.07)),
      radial-gradient(circle at 50% 50%, rgba(255,255,255,0.06), rgba(0,0,0,0.65));
    background-size:100% 2px, 3px 100%, 100% 100%;
    box-shadow: inset 0 0 120px rgba(0,0,0,0.85);
    animation:flicker 0.15s infinite;
    mix-blend-mode: screen;
    opacity: 0.95;
  }
  @keyframes flicker{ 0%{opacity:0.93} 50%{opacity:1.0} 100%{opacity:0.96} }
  canvas{ image-rendering: pixelated; }

  /* ================= å¯åŠ¨ç”»é¢ ================= */
  #startScreen{
    position:absolute; inset:0; z-index:1000;
    background: rgba(5,5,5,0.95);
    display:flex; flex-direction:column; justify-content:center; align-items:center;
    padding: 18px;
    overflow:auto;
  }
  #startScreen h1{
    font-size:48px; color:var(--term-green);
    text-shadow:0 0 10px var(--term-green), 4px 4px 0 #000;
    margin:0 0 14px 0; text-align:center; line-height:1.2; letter-spacing:2px;
  }
  #startScreen .hint{
    color:#777; font-size:14px; text-align:center; line-height:1.7;
    margin: 10px 0 16px;
    max-width: 760px;
  }
  .setup-panel{
    border:4px solid var(--term-green);
    /* åƒç´ è¾¹æ¡†é£æ ¼ */
    border-image: linear-gradient(to bottom right, #6f6, #040) 1;
    padding:16px;
    margin-bottom:18px;
    background: rgba(0,20,0,0.82);
    text-align:center;
    width: min(92vw, 620px);
    box-shadow: 0 0 0 4px #000 inset;
  }
  .setup-tabs{ display:flex; gap:10px; justify-content:center; margin-bottom:12px; flex-wrap:wrap; }
  .tab-btn{
    background:rgba(0,0,0,0.6);
    border:2px solid #2f2f2f;
    color:#bbb;
    padding:8px 12px;
    font-size:14px;
    cursor:pointer;
    box-shadow: 2px 2px 0 rgba(0,0,0,0.6);
    /* åƒç´ æŒ‰é’®é£æ ¼ */
    image-rendering: pixelated;
  }
  .tab-btn.active{
    border-color: var(--term-green);
    color: var(--term-green);
    box-shadow: 0 0 10px rgba(74,246,38,0.25);
    background: rgba(0,50,0,0.5);
  }
  .tab-btn.disabled{
    opacity:0.35;
    cursor:not-allowed;
    pointer-events:none;
    border-color:#444 !important;
    color:#666 !important;
    box-shadow:none !important;
  }

  .setup-section{ display:none; }
  .setup-section.active{ display:block; }
  .setup-grid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px 18px;
    align-items:center;
    margin-top: 8px;
  }
  .setup-row{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    font-size:16px;
    padding: 6px 8px;
    border: 1px dashed rgba(255,255,255,0.08);
    background: rgba(0,0,0,0.35);
  }
  .setup-row .label{ display:flex; gap:8px; align-items:center; white-space:nowrap; }
  input[type=number]{
    background:#000; border:2px solid var(--term-green); color:var(--term-green);
    font-family:inherit; font-size:18px; width:84px; text-align:center;
    padding: 4px 6px;
    box-shadow: inset 2px 2px 0 rgba(0,0,0,0.5);
  }
  .setup-footer{
    margin-top: 12px;
    display:flex; gap: 10px; justify-content:space-between; align-items:center;
    flex-wrap: wrap; color:#aaa; font-size: 13px;
  }
  /* åƒç´ é£æ ¼æŒ‰é’® */
  .retro-btn{
    background: #333;
    border: 4px solid;
    border-color: #666 #111 #111 #666; /* 3D bevel */
    color:var(--term-green);
    padding:14px 40px; font-size:22px; margin:8px; cursor:pointer;
    font-family:inherit; font-weight:bold;
    text-shadow: 1px 1px 0 #000;
    transition: transform 0.1s;
    min-width:200px; text-align:center;
  }
  .retro-btn:active{
    border-color: #111 #666 #666 #111; /* Inset */
    transform: translateY(2px);
  }
  .retro-btn:hover{ background:#444; color:#fff; }
  
  .retro-btn.secondary{ 
    border-color: #555 #222 #222 #555;
    color:#aaa; font-size:16px; padding:10px 18px; min-width:auto; 
  }
  .retro-btn.small{ 
    padding:8px 16px; font-size:16px; min-width:auto; margin:0; background: rgba(0,20,0,0.8);
    border-width: 2px;
  }

  .warn{
    color: var(--term-amber);
    font-size: 13px;
    line-height: 1.6;
    text-align:left;
    padding: 8px 10px;
    border: 2px solid rgba(255,176,0,0.35);
    background: rgba(20,10,0,0.35);
    width: 100%;
  }

  @media (max-width: 520px){
    #startScreen h1{ font-size:40px; }
    .setup-grid{ grid-template-columns: 1fr; }
    .setup-row{ flex-wrap:wrap; justify-content:space-between; }
    .setup-row .label{ font-size:14px; white-space:normal; text-align:left; }
    input[type=number]{ width:92px; font-size:18px; }
    #tab-player .setup-row{ flex-direction:column; align-items:stretch !important; }
    #tab-player .tab-btn{ width:100%; }
  }

  /* ================= UI å±‚ ================= */
  #uiLayer{ position:absolute; inset:0; pointer-events:none; display:none; z-index:100; padding:10px; }

  #radarContainer{
    position:absolute; top:20px; left:20px; width:180px; height:180px;
    background:#001100; border:4px solid var(--term-green); 
    border-color: #2f4f2f #002200 #002200 #2f4f2f;
    overflow:hidden; pointer-events:auto; z-index:200;
    box-shadow:0 0 15px rgba(74,246,38,0.2), inset 0 0 20px rgba(0,0,0,0.8);
    cursor: crosshair;
  }
  #radarCanvas{ width:100%; height:100%; opacity:0.9; }
  #radarTooltip{
    position:absolute; top:210px; left:20px; font-size:12px; color:var(--term-amber);
    display:none; background:rgba(0,0,0,0.8); padding:5px; border:2px solid var(--term-amber);
    pointer-events:none;
  }
  #radarClearBtn{
    position:absolute; top: 20px; left: 210px;
    width: 34px; height: 34px;
    display:none;
    pointer-events:auto; z-index: 210;
    background:#220000; border:3px solid var(--term-red); color: var(--term-red);
    border-color: #884444 #220000 #220000 #884444;
    font-weight:bold; line-height: 28px; text-align:center;
    box-shadow: 2px 2px 0 rgba(0,0,0,0.6);
  }
  #radarClearBtn:active{ border-color: #220000 #884444 #884444 #220000; transform:translateY(2px); }

  #infoPanel{
    position:absolute; top:20px; right:20px; text-align:right;
    color:var(--term-green); text-shadow:0 0 5px var(--term-green);
    font-size:16px; pointer-events:none;
    max-width: min(46vw, 340px);
  }
  .hud-row{ display:flex; align-items:center; justify-content:flex-end; margin-bottom:6px; gap:10px; flex-wrap:wrap;}
  .bar-frame{
    width:150px; height:16px; border:2px solid #555;
    background:#000; position:relative; padding:1px;
    box-shadow: inset 1px 1px 0 #000;
  }
  .bar-fill{ height:100%; transition: width 0.08s; image-rendering: pixelated; }
  #hpBar{ background-color:var(--term-red); box-shadow:inset 0 1px 0 rgba(255,255,255,0.3); }
  #cdBar{ background-color:var(--term-amber); width:0%; box-shadow:inset 0 1px 0 rgba(255,255,255,0.3); }

  #pcCdPanel{ margin-top: 8px; font-size: 13px; color:#aaa; line-height: 1.5; font-family: 'Courier New', monospace; }
  #pcCdPanel span{ color: var(--term-amber); font-weight: bold; }

  .modal-box{
    display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
    background:rgba(0,10,0,0.95); padding:6px;
    border:4px solid var(--term-green);
    border-color: #4f8 #040 #040 #4f8;
    text-align:center; pointer-events:auto; z-index:800; color:var(--term-green);
    width: min(92vw, 520px);
    box-shadow:0 0 30px rgba(0,0,0,0.8);
  }
  .modal-inner{ border:2px solid #000; padding:18px; background:rgba(0,20,0,0.9); }
  .modal-box h2{ margin-top:0; font-size: clamp(18px, 3.5vw, 28px); border-bottom:2px dashed var(--term-green); padding-bottom:10px; }

  #commandMenuPC{
    display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%);
    width:350px; background:#000; border:4px solid var(--term-green); z-index:500;
    pointer-events:auto; padding:0; box-shadow:10px 10px 0 rgba(0,0,0,0.5);
  }
  .cmd-header{ background:var(--term-green); color:#000; padding:8px; text-align:center; font-weight:bold; font-size:20px; }
  .cmd-list{ list-style:none; padding:10px; margin:0; }
  .cmd-item{
    padding:8px 10px; margin:2px 0; border:1px solid transparent; color:var(--term-green);
    cursor:pointer; display:flex; justify-content:space-between; font-size:18px;
    transition: background 0.1s;
  }
  .cmd-item:hover,.cmd-item.active{ background:rgba(74,246,38,0.2); border:1px solid var(--term-green); }
  .cmd-item.active::before{ content:'> '; }

  /* Mobile Controls (Minecraft/Pixel Style) */
  #mobileCmdBtn{
    display:none; pointer-events:auto; position:absolute; bottom:180px; right:20px;
    width:60px; height:60px; 
    background: #333;
    border: 4px solid;
    border-color: #666 #111 #111 #666;
    color:var(--term-green); font-size:16px;
    align-items:center; justify-content:center; font-weight:bold; z-index:600;
    box-shadow: 2px 2px 0 #000;
  }
  #mobileCmdBtn:active{ border-color: #111 #666 #666 #111; transform:translateY(2px); }

  #mobileCmdMenu{
    display:none; pointer-events:auto; position:absolute; bottom:180px; right:90px;
    flex-direction:column; gap:8px; z-index:600;
  }
  .m-cmd-item{
    background:#111; border:2px solid var(--term-green); color:var(--term-green);
    padding:10px 20px; font-size:16px; text-align:right; 
    box-shadow: 4px 4px 0 rgba(0,0,0,0.8); 
    font-weight:bold;
  }

  .mobile-controls{ display:none; pointer-events:auto; position:absolute; bottom:0; left:0; width:100%; height:180px; z-index:500; }
  @media (hover:none) and (pointer:coarse){
    .mobile-controls{ display:block; }
    #mobileCmdBtn{ display:flex; }
    #commandMenuPC{ display:none !important; }
    .hide-mobile{ display:none; }
    #radarContainer{ pointer-events:auto; }
    #radarTooltip{ display:none !important; }
    #infoPanel{ max-width: 62vw; }
    #radarClearBtn { left: 205px; width: 40px; height: 40px; line-height: 36px; font-size: 20px; }
  }

  /* åƒç´ åŒ–æ‘‡æ†åŒºåŸŸ */
  #joystickZone{ 
    position:absolute; bottom:30px; left:30px; width:130px; height:130px; 
    background: rgba(0,0,0,0.3);
    border: 4px solid #444;
    border-radius: 4px; /* Slight rounded for touch feel, but looks blocky */
  }
  /* åƒç´ åŒ–æ‘‡æ† */
  #stick{ 
    position:absolute; top:50%; left:50%; width:60px; height:60px; 
    background: #555;
    border: 4px solid;
    border-color: #888 #222 #222 #888;
    transform:translate(-50%, -50%); pointer-events:none; 
    box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
  }

  /* åƒç´ åŒ–æŠ€èƒ½æŒ‰é’® */
  #skillZone{ position:absolute; bottom:30px; right:30px; display:flex; gap:14px; align-items:flex-end; }
  .skill-btn{
    width:70px; height:70px; 
    background: #333;
    border: 4px solid;
    border-color: #666 #111 #111 #666;
    color:#aaa; display:flex; flex-direction:column; justify-content:center; align-items:center;
    font-size:16px; position:relative; overflow:hidden; font-weight:bold;
    text-shadow: 1px 1px 0 #000;
  }
  .skill-btn:active{
    border-color: #111 #666 #666 #111;
    transform: translateY(3px);
  }
  .skill-btn.ready{ 
    background: #1a2e1a;
    border-color: #4af626 #040 #040 #4af626;
    color:var(--term-green); 
  }
  .skill-key{ position:absolute; top:2px; left:4px; font-size:12px; opacity:0.7; }

  #btnShoot{
    width:90px; height:90px; 
    background: #3e1a1a;
    border-color: #ff5555 #400 #400 #ff5555;
    color:var(--term-red); font-size:20px;
  }
  #btnShoot:active{ border-color: #400 #f55 #f55 #400; background: #500; }

  .cooldown-overlay{
    position:absolute; bottom:0; left:0; width:100%; 
    background:rgba(0,0,0,0.6);
    transition: height 0.08s; height:0%;
    pointer-events: none;
  }

  .cmd-toast{
    position:absolute; top:30%; left:50%; transform:translate(-50%, -50%);
    font-size: clamp(16px, 3.2vw, 24px);
    color:var(--term-green); background:rgba(0,0,0,0.9);
    border:4px solid var(--term-green); padding:10px 18px;
    animation: fadeUp 2.2s forwards; pointer-events:none; z-index:800;
    text-shadow:0 0 5px var(--term-green); white-space: nowrap;
    image-rendering: pixelated;
  }
  @keyframes fadeUp{
    0%{opacity:0; transform:translate(-50%, -20%);}
    20%{opacity:1;}
    100%{opacity:0; transform:translate(-50%, -60%);}
  }

  #spectatorControls{ position:absolute; bottom:20px; width:100%; text-align:center; display:none; pointer-events:auto; z-index:300; }
  
  /* AI Mind Status (Hidden mainly, can be debug) */
  #aiDebug{ position:absolute; top:5px; left:5px; color:#333; font-size:10px; z-index:9999; pointer-events:none; }
</style>
</head>
<body>
<div id="crt-overlay"></div>
<div id="aiDebug"></div>

<div id="startScreen">
  <h1>æŒ‡æŒ¥å®˜ï¼šé™†ç©ºæ”»åŠ¿<br><span style="font-size:18px; color:#fff;">åƒç´ è¡—æœº Â· AI è¿›åŒ–ç‰ˆ v3.0</span></h1>

  <div class="setup-panel">
    <div class="setup-tabs">
      <button class="tab-btn active" data-tab="tab-blue">æˆ‘æ–¹ç¼–æˆ</button>
      <button class="tab-btn" data-tab="tab-red">æ•Œæ–¹ç¼–æˆ</button>
      <button class="tab-btn" data-tab="tab-player">æ“æ§è½½å…·</button>
    </div>

    <div id="tab-blue" class="setup-section active">
      <div class="setup-grid">
        <div class="setup-row">
          <div class="label"><span style="color:var(--term-green)">æˆ‘æ–¹å¦å…‹</span><span style="color:#666">(0~16)</span></div>
          <input type="number" id="blueTankCount" value="5" min="0" max="16">
        </div>
        <div class="setup-row">
          <div class="label"><span style="color:var(--term-green)">æˆ‘æ–¹æˆ˜æ–—æœº</span><span style="color:#666">(0~16)</span></div>
          <input type="number" id="blueJetCount" value="0" min="0" max="16">
        </div>
      </div>
      <div class="setup-footer">
        <span>æ€»æ•° â‰¤ 24ï¼Œä¸” â‰¥ 1ï¼ˆå…¨ 0 è‡ªåŠ¨æ”¹ä¸º 1 å¦å…‹ï¼‰</span>
        <span id="blueTotalInfo" style="color:#aaa">æ€»æ•°: 5</span>
      </div>
    </div>

    <div id="tab-red" class="setup-section">
      <div class="setup-grid">
        <div class="setup-row">
          <div class="label"><span style="color:var(--term-red)">æ•Œæ–¹å¦å…‹</span><span style="color:#666">(0~16)</span></div>
          <input type="number" id="redTankCount" value="5" min="0" max="16">
        </div>
        <div class="setup-row">
          <div class="label"><span style="color:var(--term-red)">æ•Œæ–¹æˆ˜æ–—æœº</span><span style="color:#666">(0~16)</span></div>
          <input type="number" id="redJetCount" value="0" min="0" max="16">
        </div>
      </div>
      <div class="setup-footer">
        <span>æ€»æ•° â‰¤ 24ï¼Œä¸” â‰¥ 1ï¼ˆå…¨ 0 è‡ªåŠ¨æ”¹ä¸º 1 å¦å…‹ï¼‰</span>
        <span id="redTotalInfo" style="color:#aaa">æ€»æ•°: 5</span>
      </div>
    </div>

    <div id="tab-player" class="setup-section">
      <div class="setup-row" style="justify-content:center; gap:12px;">
        <button class="tab-btn active" id="playerPickTank">é»˜è®¤ï¼šå¦å…‹</button>
        <button class="tab-btn" id="playerPickJet">æˆ˜æ–—æœº</button>
      </div>
      <div class="warn" style="margin-top:10px;">
        AI ç‰¹æ€§ï¼šå…·å¤‡<strong style="color:#fff">ç¾¤ä½“è¿›åŒ–</strong>èƒ½åŠ›ã€‚å®ƒä»¬ä¼šè®°ä½ä»¥å¾€æˆ˜æ–—ä¸­çš„â€œæ­»äº¡åŒºâ€å’Œâ€œå‡»æ€åŒºâ€ï¼Œå¹¶åœ¨æ–°æˆ˜å±€ä¸­è°ƒæ•´æˆ˜æœ¯ã€‚<br>
        <span style="color:#aaa">v3.0 æ›´æ–°ï¼šä¿®å¤æ®‹éª¸ç‰©ç†/ç¾åŒ–è´´å›¾/ç§»åŠ¨ç«¯åƒç´ æ§ä»¶/ä¸“å±èƒŒæ™¯éŸ³ä¹</span>
      </div>
    </div>

    <div id="setupWarn" class="warn" style="display:none; margin-top:12px;"></div>
  </div>

  <button class="retro-btn" onclick="startGame()">éƒ¨ç½²ä½œæˆ˜</button>

  <div class="hint">
    [æ“ä½œè¯´æ˜]<br>
    å¦å…‹ï¼šWASD ç§»åŠ¨ï¼ˆåæ‹‰å€’è½¦ï¼‰| ç©ºæ ¼/é¼ æ ‡å·¦é”® å¼€ç« | 1/2 æŠ€èƒ½ | TAB æˆ˜æœ¯é¢æ¿<br>
    æˆ˜æ–—æœºï¼šA/D è½¬å‘ï¼ˆæŒç»­å‰è¿›ï¼‰| ç©ºæ ¼ æ™®æ”»ç©ºæˆ˜ | 1 è¿½è¸ªå¯¼å¼¹ | 2 å¯¹åœ°æŠ•å¼¹<br>
    <span style="color:var(--term-amber)">æç¤ºï¼šåœ¨é›·è¾¾ä¸Šç‚¹å‡»å¯è®¾ç½®é›†ç»“/è½°ç‚¸åæ ‡ã€‚</span>
  </div>
</div>

<div id="deathMenu" class="modal-box">
  <div class="modal-inner">
    <h2 style="color:var(--term-red)">ä¸¥é‡æ•…éšœ</h2>
    <p>æœ¬æœºä½“ä¿¡å·ä¸¢å¤±ã€‚æ­£åœ¨å°è¯•é‡è¿...</p>
    <button class="retro-btn" onclick="gameInstance.handleTakeOver()">ğŸ“¡ æ¥ç®¡é˜Ÿå‹</button>
    <button class="retro-btn" onclick="gameInstance.handleSpectate()">ğŸ‘ï¸ è¿›å…¥è§‚æˆ˜</button>
  </div>
</div>

<div id="switchToJetMenu" class="modal-box">
  <div class="modal-inner">
    <h2 style="color:var(--term-amber)">æˆ˜å±€å˜åŒ–</h2>
    <div style="line-height:1.7; color:#ddd; margin:10px 0 16px;">
      åœ°é¢æˆ˜è¿›å…¥æ–°é˜¶æ®µã€‚ä½ å½“å‰æ“æ§ä¸º <span style="color:var(--term-amber)">å¦å…‹</span>ã€‚<br>
      æ˜¯å¦å°†è¯¥å¦å…‹ç§»äº¤ AIï¼Œå¹¶æ¥ç®¡ä¸€æ¶ <span style="color:var(--term-amber)">æˆ˜æ–—æœº</span>ï¼Ÿ
    </div>
    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
      <button class="retro-btn" onclick="gameInstance.acceptSwitchToJet(true)">åˆ‡æ¢ä¸ºæˆ˜æ–—æœº</button>
      <button class="retro-btn secondary" onclick="gameInstance.acceptSwitchToJet(false)">ç»§ç»­é©¾é©¶å¦å…‹</button>
    </div>
  </div>
</div>

<div id="modal" class="modal-box">
  <div class="modal-inner">
    <h2 id="resultTitle">ä»»åŠ¡ä¸­æ­¢</h2>
    <div id="resultStats" style="margin: 18px 0; line-height: 1.6;"></div>
    <p style="color:#aaa; font-size:12px;">æˆ˜æ–—æ•°æ®å·²ä¸Šä¼ è‡³ AI æˆ˜æœ¯æ ¸å¿ƒ</p>
    <div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
      <button class="retro-btn" onclick="gameInstance.restartGame()">é‡æ–°å¼€å§‹</button>
      <button class="retro-btn secondary" onclick="location.reload()">é€€å‡ºæˆ˜åœº</button>
    </div>
  </div>
</div>

<div id="gameContainer">
  <canvas id="gameCanvas"></canvas>

  <div id="uiLayer">
    <div id="radarContainer"><canvas id="radarCanvas" width="180" height="180"></canvas></div>
    <div id="radarClearBtn">Ã—</div>
    <div id="radarTooltip">[N] æ ‡è®°åæ ‡</div>

    <div id="infoPanel">
      <div class="hud-row">
        <span style="color:#aaa">å•ä½:</span>
        <span id="teamCount" style="color:var(--term-green)">0</span>
        <span style="font-size:14px">vs</span>
        <span id="enemyCount" style="color:var(--term-red)">0</span>
      </div>
      <div class="hud-row">
        <span>è£…ç”²</span>
        <div class="bar-frame"><div id="hpBar" class="bar-fill"></div></div>
      </div>
      <div class="hud-row">
        <span>è£…å¡«</span>
        <div class="bar-frame"><div id="cdBar" class="bar-fill"></div></div>
      </div>
      <div id="pcCdPanel" class="hide-mobile">
        <div>æŠ€èƒ½1 CD: <span id="pcCd1">0.0</span>s</div>
        <div>æŠ€èƒ½2 CD: <span id="pcCd2">0.0</span>s</div>
      </div>
      <div style="margin-top:10px; font-size:14px; color:#666;" class="hide-mobile">[TAB] æˆ˜æœ¯æŒ‡ä»¤</div>
    </div>

    <div id="commandMenuPC">
      <div class="cmd-header">æˆ˜æœ¯æŒ‡ä»¤ç»ˆç«¯</div>
      <ul class="cmd-list" id="pcCmdList">
        <li class="cmd-item active" data-cmd="RALLY"><span>ğŸš© å…¨å‘˜é›†åˆ (Rally)</span></li>
        <li class="cmd-item" data-cmd="SCATTER"><span>ğŸ” åˆ†æ•£ç´¢æ•Œ (Hunt)</span></li>
        <li class="cmd-item" data-cmd="SEARCH"><span>ğŸ›°ï¸ æœç´¢ (Search)</span></li>
        <li class="cmd-item" data-cmd="SQUAD_SMOKE"><span>ğŸ’¨ éƒ¨ç½²çƒŸé›¾ (Smoke)</span></li>
        <li class="cmd-item" data-cmd="SQUAD_EMP"><span>âš¡ éœ‡è¡æ‰“å‡» (EMP)</span></li>
      </ul>
    </div>

    <div id="mobileCmdBtn">æˆ˜æœ¯</div>
    <div id="mobileCmdMenu">
      <div class="m-cmd-item" data-cmd="RALLY">ğŸš© å…¨å‘˜é›†åˆ</div>
      <div class="m-cmd-item" data-cmd="SCATTER">ğŸ” åˆ†æ•£ç´¢æ•Œ</div>
      <div class="m-cmd-item" data-cmd="SEARCH">ğŸ›°ï¸ æœç´¢</div>
      <div class="m-cmd-item" data-cmd="SQUAD_SMOKE">ğŸ’¨ æ©æŠ¤çƒŸé›¾</div>
      <div class="m-cmd-item" data-cmd="SQUAD_EMP">âš¡ éœ‡è¡å†²å‡»</div>
    </div>

    <div id="spectateMsg" style="position:absolute; bottom:150px; width:100%; text-align:center; color:var(--term-amber); display:none; font-size: 20px; text-shadow: 2px 2px 0 #000; pointer-events: none;">
      [ è§‚æˆ˜æ¨¡å¼ ] <br> ç‚¹å‡»å±å¹•/åˆ‡æ¢æŒ‰é’® å˜æ›´è§†è§’
    </div>
    <div id="spectatorControls">
      <button class="retro-btn small" onclick="gameInstance.handleTakeOver()">æ¥ç®¡æ§åˆ¶ (T)</button>
      <button class="retro-btn small" id="mobileSpectateNext" style="margin-left:10px;">åˆ‡æ¢è§†è§’</button>
    </div>

    <div class="mobile-controls">
      <div id="joystickZone"><div id="stick"></div></div>
      <div id="skillZone">
        <div class="skill-btn ready" id="btnSkill1" data-key="1">
          <span class="skill-key">1</span>
          æŠ€èƒ½1
          <div class="cooldown-overlay"></div>
        </div>
        <div class="skill-btn ready" id="btnSkill2" data-key="2">
          <span class="skill-key">2</span>
          æŠ€èƒ½2
          <div class="cooldown-overlay"></div>
        </div>
        <div class="skill-btn" id="btnShoot" data-key="SPACE">
          å¼€ç«
          <div class="cooldown-overlay"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* ===== å¯åŠ¨é¡µï¼šè®¾ç½®æ ¡éªŒ + è®°å¿† ===== */
const SETTING_KEY = "CMD_LAND_AIR_V30";
let playerVehiclePick = "TANK";

function clampInt(v, min, max){
  v = parseInt(v);
  if (Number.isNaN(v)) v = 0;
  return Math.max(min, Math.min(max, v));
}
function normalizePlayerPickByCounts(blueTank, blueJet){
  if(blueTank + blueJet === 0){
    blueTank = 1; blueJet = 0; playerVehiclePick = "TANK";
    return {blueTank, blueJet, forcedMsg:"æˆ‘æ–¹å…¨ä¸º 0ï¼Œå·²è‡ªåŠ¨æ”¹ä¸º 1 è¾†å¦å…‹"};
  }
  if(playerVehiclePick === "TANK" && blueTank === 0){
    if(blueJet > 0) playerVehiclePick = "JET";
    else { blueTank = 1; blueJet = 0; playerVehiclePick="TANK"; }
    return {blueTank, blueJet, forcedMsg:"æ‰€é€‰è½½å…·æ•°é‡ä¸º 0ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢ä¸ºå¯ç”¨è½½å…·"};
  }
  if(playerVehiclePick === "JET" && blueJet === 0){
    if(blueTank > 0) playerVehiclePick = "TANK";
    else { blueTank = 1; blueJet = 0; playerVehiclePick="TANK"; }
    return {blueTank, blueJet, forcedMsg:"æ‰€é€‰è½½å…·æ•°é‡ä¸º 0ï¼Œå·²è‡ªåŠ¨åˆ‡æ¢ä¸ºå¯ç”¨è½½å…·"};
  }
  return {blueTank, blueJet, forcedMsg:null};
}
function refreshPlayerPickButtons(blueTank, blueJet){
  const tankBtn=document.getElementById("playerPickTank");
  const jetBtn=document.getElementById("playerPickJet");
  if(blueTank<=0) tankBtn.classList.add("disabled"); else tankBtn.classList.remove("disabled");
  if(blueJet<=0)  jetBtn.classList.add("disabled");  else jetBtn.classList.remove("disabled");
  setPlayerPickUI();
}
function updateTotalsUI(){
  let bt = clampInt(document.getElementById('blueTankCount').value, 0, 16);
  let bj = clampInt(document.getElementById('blueJetCount').value, 0, 16);
  const rt = clampInt(document.getElementById('redTankCount').value, 0, 16);
  const rj = clampInt(document.getElementById('redJetCount').value, 0, 16);

  const norm = normalizePlayerPickByCounts(bt, bj);
  bt = norm.blueTank; bj = norm.blueJet;

  if(bt + bj === 1 && clampInt(document.getElementById('blueTankCount').value,0,16)===0 && clampInt(document.getElementById('blueJetCount').value,0,16)===0){
    document.getElementById('blueTankCount').value = bt;
    document.getElementById('blueJetCount').value  = bj;
  }
  document.getElementById('blueTotalInfo').innerText = "æ€»æ•°: " + (bt + bj);
  document.getElementById('redTotalInfo').innerText  = "æ€»æ•°: " + (rt + rj);
  refreshPlayerPickButtons(bt, bj);
}
function readSetupFromLocal(){
  try{
    const raw = localStorage.getItem(SETTING_KEY);
    if(!raw) return;
    const obj = JSON.parse(raw);
    if(obj){
      document.getElementById('blueTankCount').value = clampInt(obj.blueTank ?? 5, 0, 16);
      document.getElementById('blueJetCount').value  = clampInt(obj.blueJet ?? 0, 0, 16);
      document.getElementById('redTankCount').value  = clampInt(obj.redTank ?? 5, 0, 16);
      document.getElementById('redJetCount').value   = clampInt(obj.redJet ?? 0, 0, 16);
      playerVehiclePick = (obj.playerType === "JET") ? "JET" : "TANK";
      setPlayerPickUI();
      updateTotalsUI();
    }
  }catch(e){}
}
function saveSetupToLocal(setup){
  try{ localStorage.setItem(SETTING_KEY, JSON.stringify(setup)); }catch(e){}
}
function setPlayerPickUI(){
  const a = document.getElementById("playerPickTank");
  const b = document.getElementById("playerPickJet");
  if(playerVehiclePick === "JET"){
    a.classList.remove("active"); b.classList.add("active");
    a.innerText = "å¦å…‹"; b.innerText = "é€‰æ‹©ï¼šæˆ˜æ–—æœº";
  }else{
    b.classList.remove("active"); a.classList.add("active");
    b.innerText = "æˆ˜æ–—æœº"; a.innerText = "é»˜è®¤ï¼šå¦å…‹";
  }
}

(function initStartUI(){
  document.querySelectorAll(".tab-btn[data-tab]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      document.querySelectorAll(".tab-btn[data-tab]").forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      const tab = btn.dataset.tab;
      document.querySelectorAll(".setup-section").forEach(sec=>sec.classList.remove("active"));
      document.getElementById(tab).classList.add("active");
    });
  });
  ["blueTankCount","blueJetCount","redTankCount","redJetCount"].forEach(id=>{
    document.getElementById(id).addEventListener("input", ()=>{
      updateTotalsUI();
      document.getElementById("setupWarn").style.display = "none";
    });
  });
  document.getElementById("playerPickTank").addEventListener("click", ()=>{
    const bt = clampInt(document.getElementById('blueTankCount').value, 0, 16);
    if(bt<=0) return;
    playerVehiclePick = "TANK"; setPlayerPickUI();
    // ç”¨æˆ·äº¤äº’åï¼Œå¯ä»¥å®‰å…¨æ’­æ”¾éŸ³ä¹
    AudioSys.initMenuMusic();
  });
  document.getElementById("playerPickJet").addEventListener("click", ()=>{
    const bj = clampInt(document.getElementById('blueJetCount').value, 0, 16);
    if(bj<=0) return;
    playerVehiclePick = "JET"; setPlayerPickUI();
    AudioSys.initMenuMusic();
  });
  
  // ä»»æ„äº¤äº’åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡
  document.body.addEventListener('click', ()=>AudioSys.initMenuMusic(), {once:true});
  document.body.addEventListener('touchstart', ()=>AudioSys.initMenuMusic(), {once:true});

  readSetupFromLocal();
  updateTotalsUI();
})();

/* ===== Audio (Fix 2: Dedicated Menu Music & Fix Intermittent) ===== */
const AudioSys = {
  ctx:null, masterGain:null, 
  sequencerTimer:null, step:0, 
  menuOscillators: [], 
  mode: 'NONE', // 'NONE', 'MENU', 'GAME'

  initContext(){
    if(this.ctx) return;
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AC();
    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.35;
    const compressor = this.ctx.createDynamicsCompressor();
    compressor.threshold.value = -20; compressor.ratio.value = 12;
    this.masterGain.connect(compressor);
    compressor.connect(this.ctx.destination);
  },

  initMenuMusic(){
    if(this.mode === 'MENU' || this.mode === 'GAME') return;
    this.initContext();
    if(this.ctx.state === 'suspended') this.ctx.resume();
    
    this.mode = 'MENU';
    this.stopSequencer();
    
    // Slow, dark ambient drone for menu
    const freqs = [55, 110, 165]; // A1, A2, E3 approx
    freqs.forEach((f, i) => {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = i===0?'square':'sine';
      osc.frequency.value = f;
      // Detune for thickness
      osc.detune.value = (Math.random()-0.5)*10;
      
      gain.gain.value = 0;
      osc.connect(gain);
      gain.connect(this.masterGain);
      osc.start();
      
      // Fade in
      gain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 2);
      
      // LFO for movement
      const lfo = this.ctx.createOscillator();
      lfo.frequency.value = 0.1 + Math.random()*0.1;
      const lfoGain = this.ctx.createGain();
      lfoGain.gain.value = 0.02;
      lfo.connect(lfoGain);
      lfoGain.connect(gain.gain);
      lfo.start();

      this.menuOscillators.push({osc, gain, lfo, lfoGain});
    });
  },

  stopMenuMusic(){
    if(this.mode !== 'MENU') return;
    this.menuOscillators.forEach(o => {
      try{
        o.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.5);
        o.osc.stop(this.ctx.currentTime + 1);
        o.lfo.stop(this.ctx.currentTime + 1);
      }catch(e){}
    });
    this.menuOscillators = [];
  },

  playOsc(freq,type,start,dur,vol,detune=0){
    if(!this.ctx) return;
    const osc=this.ctx.createOscillator();
    const gain=this.ctx.createGain();
    osc.type=type;
    osc.frequency.setValueAtTime(freq,start);
    osc.detune.value=detune;
    gain.gain.setValueAtTime(vol,start);
    gain.gain.exponentialRampToValueAtTime(0.001,start+dur);
    osc.connect(gain); gain.connect(this.masterGain);
    osc.start(start); osc.stop(start+dur);
  },
  playNoise(start,dur,vol,filterFreq=null){
    if(!this.ctx) return;
    const bufferSize = Math.max(1, Math.floor(this.ctx.sampleRate*dur));
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++) data[i]=Math.random()*2-1;
    const noise=this.ctx.createBufferSource(); noise.buffer=buffer;
    const gain=this.ctx.createGain();
    if(filterFreq){
      const filter=this.ctx.createBiquadFilter();
      filter.type='lowpass'; filter.frequency.value=filterFreq;
      noise.connect(filter); filter.connect(gain);
    }else noise.connect(gain);
    gain.gain.setValueAtTime(vol,start);
    gain.gain.exponentialRampToValueAtTime(0.001,start+dur);
    gain.connect(this.masterGain);
    noise.start(start);
  },
  playKick(t){ this.playOsc(150,'square',t,0.1,0.5); this.playOsc(60,'sine',t,0.3,0.8); },
  playSnare(t){ this.playNoise(t,0.15,0.4,2000); this.playOsc(200,'triangle',t,0.05,0.2); },
  playHiHat(t){ this.playNoise(t,0.05,0.1,8000); },
  
  startGameMusic(){
    this.stopMenuMusic();
    if(!this.ctx) this.initContext();
    if(this.ctx.state === 'suspended') this.ctx.resume();
    this.mode = 'GAME';
    this.startSequencer();
  },

  startSequencer(){
    const tempo=110, spb=60/tempo, lookahead=25.0, scheduleAhead=0.1;
    let nextTime=this.ctx.currentTime;
    const scheduler=()=>{
      if(this.mode !== 'GAME') return;
      while(nextTime < this.ctx.currentTime + scheduleAhead){
        this.scheduleNote(this.step,nextTime);
        nextTime += spb/4;
        this.step = (this.step+1)%16;
      }
      this.sequencerTimer = setTimeout(scheduler, lookahead);
    };
    scheduler();
  },
  stopSequencer(){
    if(this.sequencerTimer) clearTimeout(this.sequencerTimer);
  },
  scheduleNote(step,time){
    // Bassline
    if(step%2===0){
      const freq=[65.41,65.41,77.78,65.41,65.41,65.41,87.31,98.00][Math.floor(step/2)%8];
      this.playOsc(freq,'sawtooth',time,0.15,0.12,-5);
      this.playOsc(freq,'sawtooth',time,0.15,0.12,5);
    }
    // Drums
    if(step%8===0) this.playKick(time);
    if(step%8===4) this.playSnare(time);
    if(step%2===0) this.playHiHat(time);
    // Arp
    if([0,3,6,9,12,14].includes(step)){
      const arp=[261.63,311.13,392.00,523.25];
      const note=arp[Math.floor(Math.random()*arp.length)];
      this.playOsc(note,'square',time,0.1,0.04);
    }
  },
  
  // SFX
  sfxShoot(){ const t=this.ctx.currentTime; this.playNoise(t,0.2,0.35,3000); this.playOsc(150,'square',t,0.1,0.18); },
  sfxExplode(){ const t=this.ctx.currentTime; this.playNoise(t,0.8,0.55,800); this.playOsc(50,'sawtooth',t,0.6,0.35); },
  sfxHit(){ this.playOsc(300,'triangle',this.ctx.currentTime,0.1,0.1); },
  sfxSkill(){ const t=this.ctx.currentTime; this.playOsc(600,'sine',t,0.5,0.18); this.playNoise(t,0.5,0.25,2000); },
  sfxEmp(){
    const t=this.ctx.currentTime;
    const osc=this.ctx.createOscillator(), gain=this.ctx.createGain();
    osc.frequency.setValueAtTime(800,t);
    osc.frequency.exponentialRampToValueAtTime(50,t+0.5);
    gain.gain.setValueAtTime(0.5,t);
    gain.gain.exponentialRampToValueAtTime(0.01,t+0.5);
    osc.connect(gain); gain.connect(this.masterGain);
    osc.start(t); osc.stop(t+0.5);
  },
  sfxCmd(){ const t=this.ctx.currentTime; this.playOsc(880,'square',t,0.08,0.1); this.playOsc(1760,'square',t+0.1,0.08,0.1); },
  sfxJetGun(){ const t=this.ctx.currentTime; this.playOsc(900,'square',t,0.06,0.08); this.playNoise(t,0.09,0.08,6000); },
  sfxMissile(){ const t=this.ctx.currentTime; this.playOsc(240,'sawtooth',t,0.25,0.12); this.playOsc(120,'sine',t,0.45,0.08); this.playNoise(t,0.2,0.12,1800); },
  sfxBomb(){ const t=this.ctx.currentTime; this.playOsc(140,'triangle',t,0.35,0.12); this.playNoise(t,0.25,0.10,900); },
  sfxAa(){ const t=this.ctx.currentTime; this.playOsc(520,'square',t,0.08,0.12); this.playOsc(260,'square',t+0.05,0.12,0.10); this.playNoise(t,0.18,0.10,2500); },
  
  stop(){
    this.stopSequencer();
    this.stopMenuMusic();
    this.mode = 'NONE';
  }
};

/* ===== AI Mind: The "True Intelligence" System ===== */
/* This system learns from past games by storing "Heat Maps" of deaths and kills. */
const AIGlobalMind = {
  // Grid size corresponding to map tiles
  width: 50, height: 50,
  data: {
    // Stores aggregated "danger" score: +1 for ally death, -1 for enemy death (simplified)
    // Actually: 
    // killMap: Where enemies died (Good for attacking)
    // deathMap: Where allies died (Bad, avoid)
    killMap: [], 
    deathMap: [],
    // Evolutionary weights
    genes: { aggression: 0.6, caution: 0.3, teamwork: 0.5 },
    gamesPlayed: 0
  },
  
  init(){
    this.data.killMap = new Array(this.width * this.height).fill(0);
    this.data.deathMap = new Array(this.width * this.height).fill(0);
    this.load();
  },

  load(){
    try {
      const raw = localStorage.getItem("AI_MIND_V30");
      if(raw) {
        const parsed = JSON.parse(raw);
        // Merge logic to ensure compatibility
        if(parsed.killMap && parsed.killMap.length === this.data.killMap.length) this.data = parsed;
      }
    } catch(e) { console.warn("AI Mind load failed", e); }
  },

  save(){
    try {
      localStorage.setItem("AI_MIND_V30", JSON.stringify(this.data));
    } catch(e) {}
  },

  // Record an event: Unit Type, Team, X, Y
  recordEvent(team, x, y, isDeath){
    const tx = Math.floor(x / CFG.tileSize);
    const ty = Math.floor(y / CFG.tileSize);
    if(tx < 0 || tx >= this.width || ty < 0 || ty >= this.height) return;
    const idx = ty * this.width + tx;

    // AI controls RED team usually (or non-player units)
    // If RED dies -> Bad spot (DeathMap for Red)
    // If BLUE dies -> Good spot (KillMap for Red)
    
    // We assume AI learns for "The Computer" (Red Team primarily, but Blue AI also uses it)
    if(team === CFG.teams.RED && isDeath) {
      this.data.deathMap[idx] = Math.min(255, this.data.deathMap[idx] + 1);
    } else if (team === CFG.teams.BLUE && isDeath) {
      this.data.killMap[idx] = Math.min(255, this.data.killMap[idx] + 1);
    }
  },

  // Called at end of game to evolve genes
  evolve(aiWon){
    this.data.gamesPlayed++;
    // Decay maps slightly to allow shifting tactics
    for(let i=0; i<this.data.deathMap.length; i++){
      if(Math.random()<0.05) this.data.deathMap[i] = Math.max(0, this.data.deathMap[i]-1);
      if(Math.random()<0.05) this.data.killMap[i] = Math.max(0, this.data.killMap[i]-1);
    }

    // Adjust genes: If AI lost, try changing strategy
    if(!aiWon){
      // Randomly tweak
      const key = Math.random() > 0.5 ? 'aggression' : (Math.random()>0.5 ? 'caution' : 'teamwork');
      this.data.genes[key] += (Math.random() - 0.5) * 0.1;
      this.data.genes[key] = Math.max(0.1, Math.min(1.0, this.data.genes[key]));
    }
    this.save();
  },

  // Query: Get tactical score for a position (0-1)
  // Higher = Better position to be in
  getTacticalScore(x, y){
    const tx = Math.floor(x / CFG.tileSize);
    const ty = Math.floor(y / CFG.tileSize);
    if(tx < 0 || tx >= this.width || ty < 0 || ty >= this.height) return 0.5;
    const idx = ty * this.width + tx;

    const deathRisk = this.data.deathMap[idx]; 
    const killOpportunity = this.data.killMap[idx];
    
    // Normalize crudely (assuming max accumulation around 20-50 per tile in short term)
    const risk = Math.min(1, deathRisk / 10);
    const reward = Math.min(1, killOpportunity / 10);

    // AI wants: High Reward, Low Risk
    // Score: 0.5 base - Risk*Caution + Reward*Aggression
    let score = 0.5 - (risk * this.data.genes.caution) + (reward * this.data.genes.aggression);
    return Math.max(0, Math.min(1, score));
  }
};
AIGlobalMind.init();

/* ===== å¯åŠ¨æ¸¸æˆ ===== */
function startGame(){
  let blueTank = clampInt(document.getElementById('blueTankCount').value, 0, 16);
  let blueJet  = clampInt(document.getElementById('blueJetCount').value, 0, 16);
  let redTank  = clampInt(document.getElementById('redTankCount').value, 0, 16);
  let redJet   = clampInt(document.getElementById('redJetCount').value, 0, 16);
  const warnEl = document.getElementById("setupWarn");
  warnEl.style.display="none";

  const bTotal = blueTank + blueJet;
  const rTotal = redTank + redJet;
  let warns=[];
  if(bTotal>24) warns.push("æˆ‘æ–¹æ€»æ•°è¶…è¿‡ 24");
  if(rTotal>24) warns.push("æ•Œæ–¹æ€»æ•°è¶…è¿‡ 24");

  if(bTotal===0){ blueTank=1; blueJet=0; warns.push("æˆ‘æ–¹å…¨ä¸º 0ï¼Œå·²è‡ªåŠ¨æ”¹ä¸º 1 è¾†å¦å…‹"); }
  if(rTotal===0){ redTank=1; redJet=0; warns.push("æ•Œæ–¹å…¨ä¸º 0ï¼Œå·²è‡ªåŠ¨æ”¹ä¸º 1 è¾†å¦å…‹"); }

  const norm = normalizePlayerPickByCounts(blueTank, blueJet);
  blueTank = norm.blueTank;
  blueJet  = norm.blueJet;
  if(norm.forcedMsg) warns.push(norm.forcedMsg);

  document.getElementById('blueTankCount').value = blueTank;
  document.getElementById('blueJetCount').value  = blueJet;
  updateTotalsUI();

  if(warns.length){
    warnEl.innerHTML = "è®¾ç½®è­¦å‘Šï¼š<br>" + warns.map(s=>"â€¢ "+s).join("<br>");
    warnEl.style.display="block";
  }

  saveSetupToLocal({ blueTank, blueJet, redTank, redJet, playerType:(playerVehiclePick==="JET")?"JET":"TANK" });
  
  AudioSys.startGameMusic();
  
  document.getElementById('startScreen').style.display='none';
  document.getElementById('uiLayer').style.display='block';
  window.gameInstance = new Game(blueTank, blueJet, redTank, redJet, playerVehiclePick);
}

/* ===== å·¥å…·ä¸é…ç½® ===== */
const CFG = {
  tileSize: 40,
  mapWidth: 50,
  mapHeight: 50,

  tankRadius: 16,
  tankSpeed: 110,
  tankTurnSpeed: 3.5,

  bulletSpeed: 350,
  bulletLife: 2.0,
  fireRate: 1.5,
  visionDist: 550,
  radarPeriod: 3.0,

  smokeDuration: 8.0,
  empDuration: 3.0,

  jetSpeed: 130,
  jetTurnSpeed: 2.35,
  jetGunRate: 0.25,
  jetGunSpeed: 520,
  jetGunLife: 1.0,
  jetHp: 90,
  jetVision: 820,
  jetWreckRadius: 12, // Fix 1: Collision size for wrecks

  missileSpeed: 520,
  missileTurn: 2.2,
  missileLife: 3.1,
  missileDamage: 42,

  bombFallTime: 0.55,
  bombRadius: 165,
  bombDamage: 78,

  crashRadius: 130,
  crashDamage: 55,

  aaSpeed: 780,
  aaTurn: 4.6,

  teams: { BLUE:1, RED:2 }
};
const EnemyStats = { speedMult: 0.9, dmgMult: 0.7, fireRateMult: 0.85 };
const AUTO_AIM_ANGLE = 15;

const MathUtils = {
  degToRad:d=>d*Math.PI/180,
  dist:(x1,y1,x2,y2)=>Math.hypot(x2-x1,y2-y1),
  clamp:(v,min,max)=>Math.max(min,Math.min(max,v)),
  angleDiff:(a,b)=>{
    let d=a-b;
    while(d>Math.PI) d-=Math.PI*2;
    while(d<-Math.PI) d+=Math.PI*2;
    return d;
  },
  lerp:(a,b,t)=>a+(b-a)*t,
  lerpAngle:(a,b,t)=>{
    let d=b-a;
    while(d>Math.PI) d-=Math.PI*2;
    while(d<-Math.PI) d+=Math.PI*2;
    return a+d*t;
  },
  rand:(min,max)=>Math.random()*(max-min)+min,
  lineIntersectsCircle:(x1,y1,x2,y2,cx,cy,r)=>{
    const dx=x2-x1, dy=y2-y1;
    const lenSq=dx*dx+dy*dy || 1e-9;
    const u=((cx-x1)*dx+(cy-y1)*dy)/lenSq;
    let px,py;
    if(u<0){px=x1;py=y1;} else if(u>1){px=x2;py=y2;} else {px=x1+u*dx;py=y1+u*dy;}
    const dsq=(cx-px)*(cx-px)+(cy-py)*(cy-py);
    return dsq < r*r;
  }
};

const Noise = {
  perm:[],
  init(){
    this.perm=[];
    for(let i=0;i<256;i++) this.perm[i]=Math.floor(Math.random()*256);
    for(let i=0;i<256;i++) this.perm[i+256]=this.perm[i];
  },
  fade:t=>t*t*t*(t*(t*6-15)+10),
  lerp:(t,a,b)=>a+t*(b-a),
  grad(hash,x,y){
    const h=hash&15;
    const u=h<8?x:y, v=h<4?y:(h===12||h===14?x:0);
    return ((h&1)===0?u:-u) + ((h&2)===0?v:-v);
  },
  perlin(x,y){
    if(this.perm.length===0) this.init();
    const X=Math.floor(x)&255, Y=Math.floor(y)&255;
    x-=Math.floor(x); y-=Math.floor(y);
    const u=this.fade(x), v=this.fade(y);
    const A=this.perm[X]+Y, B=this.perm[X+1]+Y;
    return this.lerp(v,
      this.lerp(u, this.grad(this.perm[A],x,y), this.grad(this.perm[B],x-1,y)),
      this.lerp(u, this.grad(this.perm[A+1],x,y-1), this.grad(this.perm[B+1],x-1,y-1))
    );
  }
};

const Pathfinder = {
  findPath(sx,sy,ex,ey,map){
    const w=map[0].length, h=map.length;
    const s={x:Math.floor(sx/CFG.tileSize), y:Math.floor(sy/CFG.tileSize)};
    const e={x:Math.floor(ex/CFG.tileSize), y:Math.floor(ey/CFG.tileSize)};
    if(s.x<0||s.x>=w||s.y<0||s.y>=h) return [];
    if(e.x<0||e.x>=w||e.y<0||e.y>=h) return [];

    if(map[e.y][e.x]>0){
      let found=false;
      for(let r=1;r<4;r++){
        for(let dy=-r;dy<=r;dy++){
          for(let dx=-r;dx<=r;dx++){
            const nx=e.x+dx, ny=e.y+dy;
            if(nx>=0&&nx<w&&ny>=0&&ny<h&&map[ny][nx]===0){ e.x=nx; e.y=ny; found=true; break; }
          }
          if(found) break;
        }
        if(found) break;
      }
      if(!found) return [];
    }

    const open=[], closed=new Set();
    s.g=0; s.h=Math.abs(s.x-e.x)+Math.abs(s.y-e.y); s.f=s.g+s.h; s.parent=null;
    open.push(s);

    let steps=0; const MAX=650;
    while(open.length && steps<MAX){
      steps++;
      open.sort((a,b)=>a.f-b.f);
      const cur=open.shift();
      if(cur.x===e.x && cur.y===e.y){
        const path=[];
        let c=cur;
        while(c){
          path.push({x:c.x*CFG.tileSize+CFG.tileSize/2, y:c.y*CFG.tileSize+CFG.tileSize/2});
          c=c.parent;
        }
        return path.reverse();
      }
      closed.add(cur.x+","+cur.y);
      const neigh=[{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0},{x:-1,y:-1},{x:1,y:-1},{x:-1,y:1},{x:1,y:1}];
      for(const o of neigh){
        const nx=cur.x+o.x, ny=cur.y+o.y;
        if(nx<0||nx>=w||ny<0||ny>=h) continue;
        if(map[ny][nx]>0) continue;
        if(closed.has(nx+","+ny)) continue;
        if(Math.abs(o.x)===1 && Math.abs(o.y)===1){
          if(map[cur.y][nx]>0 || map[ny][cur.x]>0) continue;
        }
        const g = cur.g + ((Math.abs(o.x)===1 && Math.abs(o.y)===1) ? 1.414 : 1);
        let n=open.find(p=>p.x===nx&&p.y===ny);
        if(!n){
          n={x:nx,y:ny,parent:cur,g};
          n.h=Math.abs(nx-e.x)+Math.abs(ny-e.y);
          n.f=n.g+n.h;
          open.push(n);
        }else if(g<n.g){
          n.g=g; n.parent=cur; n.f=n.g+n.h;
        }
      }
    }
    return [];
  }
};

/* ===== åƒç´ è´´å›¾ç¼“å­˜ ===== */
const SpriteCache = {
  tank:{BLUE:null,RED:null,PLAYER:null,DISABLED:null,WRECK:null},
  jet:{BLUE:null,RED:null,PLAYER:null,WRECK:null},
  makeCanvas(w,h){ const c=document.createElement("canvas"); c.width=w; c.height=h; return c; },
  init(){
    if(this.tank.BLUE) return;
    this.tank.BLUE=this.drawTankSprite("#4a6e55","#2f4f3a",false,false);
    this.tank.RED=this.drawTankSprite("#8c4b4b","#5e2d2d",false,false);
    this.tank.PLAYER=this.drawTankSprite("#b58e3a","#6a5420",true,false);
    this.tank.DISABLED=this.drawTankSprite("#444","#2b2b2b",false,true);
    this.tank.WRECK=this.drawWreckSprite();

    this.jet.BLUE=this.drawJetSprite("#4a6e55","#2f4f3a",false);
    this.jet.RED=this.drawJetSprite("#8c4b4b","#5e2d2d",false);
    this.jet.PLAYER=this.drawJetSprite("#b58e3a","#6a5420",true);
    // Fix 4: Improved Jet Wreck Sprite
    this.jet.WRECK=this.drawJetWreckSprite(); 
  },
  drawTankSprite(main,detail,isPlayer=false,disabled=false){
    const c=this.makeCanvas(40,40), ctx=c.getContext("2d");
    ctx.imageSmoothingEnabled=false; ctx.clearRect(0,0,40,40);

    ctx.fillStyle="#111"; ctx.fillRect(4,7,32,8); ctx.fillRect(4,25,32,8);
    ctx.fillStyle="#222";
    for(let i=4;i<36;i+=4){ ctx.fillRect(i,7,2,8); ctx.fillRect(i,25,2,8); }

    ctx.fillStyle=main; ctx.fillRect(4,15,32,10);
    ctx.fillStyle="rgba(255,255,255,0.08)"; ctx.fillRect(4,15,32,1);

    ctx.fillStyle=detail; ctx.fillRect(12,13,12,14);
    ctx.fillStyle=detail; ctx.fillRect(16,13,12,14);
    ctx.fillStyle="#111"; ctx.fillRect(22,18,14,4);
    ctx.fillStyle="#333"; ctx.fillRect(34,17,3,6);

    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.fillRect(7,16,2,2); ctx.fillRect(10,19,2,2); ctx.fillRect(28,19,2,2);

    ctx.strokeStyle="rgba(0,0,0,0.65)"; ctx.lineWidth=1;
    ctx.strokeRect(4.5,7.5,31,26);

    if(isPlayer){ ctx.fillStyle="rgba(255,176,0,0.18)"; ctx.fillRect(4,15,32,10); }
    if(disabled){ ctx.fillStyle="rgba(74,246,38,0.10)"; ctx.fillRect(0,0,40,40); }
    return c;
  },
  drawWreckSprite(){
    const c=this.makeCanvas(40,40), ctx=c.getContext("2d");
    ctx.imageSmoothingEnabled=false; ctx.clearRect(0,0,40,40);
    ctx.fillStyle="#222"; ctx.fillRect(6,10,28,20);
    ctx.fillStyle="#111"; ctx.fillRect(10,14,20,12);
    ctx.fillStyle="#333"; ctx.fillRect(17,18,10,4);
    ctx.fillStyle="rgba(255,255,255,0.04)"; ctx.fillRect(6,10,28,1);
    ctx.strokeStyle="rgba(0,0,0,0.65)"; ctx.strokeRect(6.5,10.5,27,19);
    return c;
  },
  drawJetSprite(main,detail,isPlayer=false){
    const c=this.makeCanvas(64,64), ctx=c.getContext("2d");
    ctx.imageSmoothingEnabled=false; ctx.clearRect(0,0,64,64);

    const poly=(pts, fill=true, stroke=false, sCol="rgba(0,0,0,0.55)")=>{
      ctx.beginPath();
      ctx.moveTo(pts[0][0],pts[0][1]);
      for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i][0],pts[i][1]);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke){ ctx.strokeStyle=sCol; ctx.lineWidth=1; ctx.stroke(); }
    };

    ctx.fillStyle="rgba(0,0,0,0.55)";
    poly([[52,32],[42,23],[28,20],[20,25],[18,32],[20,39],[28,44],[42,41]]);

    ctx.fillStyle=main;
    poly([[52,32],[43,24],[30,21],[20,26],[18,32],[20,38],[30,43],[43,40]]);

    ctx.fillStyle=detail;
    poly([[36,18],[28,20],[20,26],[26,28],[34,26],[42,22]]);
    poly([[36,46],[28,44],[20,38],[26,36],[34,38],[42,42]]);

    ctx.fillStyle="rgba(255,255,255,0.10)";
    ctx.fillRect(48,31,3,2);
    ctx.fillStyle="rgba(0,0,0,0.25)";
    ctx.fillRect(50,31,2,2);

    ctx.fillStyle="rgba(0,0,0,0.35)";
    ctx.fillRect(34,26,2,12);
    ctx.fillRect(38,26,2,12);
    ctx.fillStyle="rgba(0,0,0,0.22)";
    ctx.fillRect(30,30,4,4);

    ctx.fillStyle="#0b0f16";
    ctx.fillRect(36,28,9,8);
    ctx.fillStyle="rgba(180,220,255,0.14)";
    ctx.fillRect(36,28,9,1);
    ctx.fillRect(36,29,3,1);
    ctx.fillRect(40,30,2,1);

    ctx.fillStyle="#101010";
    poly([[26,28],[22,26],[20,28],[23,31]], true, true, "rgba(0,0,0,0.65)");
    poly([[26,36],[22,38],[20,36],[23,33]], true, true, "rgba(0,0,0,0.65)");

    ctx.strokeStyle="rgba(0,0,0,0.55)";
    ctx.lineWidth=1;
    ctx.beginPath();
    ctx.moveTo(34,27); ctx.lineTo(46,32); ctx.lineTo(34,37);
    ctx.stroke();

    ctx.strokeStyle="rgba(255,255,255,0.06)";
    ctx.beginPath();
    ctx.moveTo(29,24); ctx.lineTo(41,24);
    ctx.moveTo(29,40); ctx.lineTo(41,40);
    ctx.stroke();

    ctx.fillStyle="#0d0d0d";
    ctx.fillRect(18,30,5,4);
    ctx.fillStyle="rgba(255,176,0,0.12)";
    ctx.fillRect(18,31,2,2);

    ctx.strokeStyle="rgba(0,0,0,0.65)";
    ctx.lineWidth=1;
    poly([[52,32],[43,24],[30,21],[20,26],[18,32],[20,38],[30,43],[43,40]], false, true);

    if(isPlayer){
      ctx.fillStyle="rgba(255,176,0,0.16)";
      ctx.fillRect(22,22,26,20);
    }
    ctx.fillStyle="#111";
    ctx.fillRect(39,22,2,2);
    ctx.fillRect(39,40,2,2);
    return c;
  },
  drawJetWreckSprite(){
    // Fix 4: More detailed wreck
    const c=this.makeCanvas(64,64), ctx=c.getContext("2d");
    ctx.imageSmoothingEnabled=false; ctx.clearRect(0,0,64,64);
    
    // Burnt fuselage
    ctx.fillStyle="#222"; 
    ctx.beginPath(); ctx.moveTo(50,32); ctx.lineTo(35,28); ctx.lineTo(20,32); ctx.lineTo(35,36); ctx.fill();
    
    // Broken wings
    ctx.fillStyle="#333";
    ctx.beginPath(); ctx.moveTo(35,28); ctx.lineTo(30,15); ctx.lineTo(40,20); ctx.fill(); // Left wing stump
    ctx.beginPath(); ctx.moveTo(35,36); ctx.lineTo(28,42); ctx.lineTo(38,40); ctx.fill(); // Right wing broken
    
    // Scorch marks
    ctx.fillStyle="#000"; ctx.fillRect(30,30,10,4);
    ctx.fillStyle="#111"; ctx.fillRect(25,28,4,4);
    
    // Debris pixels
    ctx.fillStyle="rgba(80,80,80,0.8)";
    for(let i=0; i<8; i++){
        ctx.fillRect(20+Math.random()*30, 20+Math.random()*24, 2, 2);
    }
    
    return c;
  }
};

/* ===== ä¸»è¦æ¸¸æˆç±» ===== */
class Game{
  constructor(blueTank, blueJet, redTank, redJet, playerPick){
    this.canvas=document.getElementById('gameCanvas');
    this.ctx=this.canvas.getContext('2d');
    this.radarCanvas=document.getElementById('radarCanvas');
    this.radarCtx=this.radarCanvas.getContext('2d');
    this.bgCanvas=document.createElement('canvas');
    this.bgCtx=this.bgCanvas.getContext('2d');

    this.blueTankCount=MathUtils.clamp(blueTank,0,16);
    this.blueJetCount=MathUtils.clamp(blueJet,0,16);
    this.redTankCount=MathUtils.clamp(redTank,0,16);
    this.redJetCount=MathUtils.clamp(redJet,0,16);
    this.playerPick=(playerPick==="JET")?"JET":"TANK";

    this.lastTime=0; this.width=0; this.height=0;
    this.map=[];
    this.tanks=[]; this.jets=[];
    this.bullets=[]; this.airBullets=[];
    this.missiles=[]; this.bombs=[]; this.aaMissiles=[];
    this.particles=[]; this.smokes=[]; this.fx=[];
    this.radarAlerts=[]; this.supportSignals=[];
    this.dangerZones=[];

    this.camera={x:0,y:0}; this.cameraAngle=0;
    this.player=null; this.spectating=false; this.cameraTarget=null;
    this.radarAngle=0; this.radarMemory=[];
    this.keys={}; this.touchInput={x:0,y:0,shooting:false};
    this.gameOver=false;

    this.menuOpen=false; this.selectedCmdIndex=0; this.activeCommand=null;
    this.deathMenuOpen=false;

    this.mouseOnRadar=false;
    this.radarMousePos={x:0,y:0};
    this.customRallyPoint=null;
    this.markAge=0;

    this.uiTimer=0;
    this.aaStrike={active:false,targetTeam:null,spawned:false};

    this.searchOp=null;
    this.searchRallyPoint=null;
    this.engageTimer={1:0,2:0};
    this.offerSwitchDone=false;
    this.offerSwitchDeclined=false;

    this.init();
  }

  init(){
    SpriteCache.init();
    this.resize();
    window.addEventListener('resize', ()=>this.resize());
    this.bindControls();
    this.generateMap();
    this.spawnUnits();
    this.lastTime=performance.now();
    requestAnimationFrame(t=>this.loop(t));
  }

  restartGame(){
    saveSetupToLocal({
      blueTank:this.blueTankCount, blueJet:this.blueJetCount,
      redTank:this.redTankCount, redJet:this.redJetCount,
      playerType:(this.playerPick==="JET")?"JET":"TANK"
    });
    location.reload();
  }

  resize(){
    this.width=window.innerWidth; this.height=window.innerHeight;
    this.canvas.width=this.width; this.canvas.height=this.height;
    this.ctx.imageSmoothingEnabled=false;
  }

  generateMap(){
    Noise.init();
    this.map=[];
    for(let y=0;y<CFG.mapHeight;y++){
      const row=[];
      for(let x=0;x<CFG.mapWidth;x++){
        if(x===0||x===CFG.mapWidth-1||y===0||y===CFG.mapHeight-1){ row.push(1); continue; }
        let n=Noise.perlin(x*0.15,y*0.15);
        if(n>0.4) row.push(1);
        else if(n>0.15) row.push(2);
        else row.push(0);
      }
      this.map.push(row);
    }
    this.clearZone(5,5,8);
    this.clearZone(CFG.mapWidth-8, CFG.mapHeight-8, 8);
    this.renderStaticMap();
  }

  renderStaticMap(){
    this.bgCanvas.width=CFG.mapWidth*CFG.tileSize;
    this.bgCanvas.height=CFG.mapHeight*CFG.tileSize;
    const ctx=this.bgCtx; ctx.imageSmoothingEnabled=false;
    for(let y=0;y<CFG.mapHeight;y++){
      for(let x=0;x<CFG.mapWidth;x++){
        this.drawTileToBg(x,y,this.map[y][x]);
      }
    }
  }

  drawTileToBg(x,y,tile){
    const ctx=this.bgCtx;
    const px=x*CFG.tileSize, py=y*CFG.tileSize;
    if(tile===1){
      ctx.fillStyle='#1b1b1b'; ctx.fillRect(px,py,CFG.tileSize,CFG.tileSize);
      ctx.fillStyle='#2a2a2a'; ctx.fillRect(px,py,CFG.tileSize,3); ctx.fillRect(px,py,3,CFG.tileSize);
      ctx.fillStyle='#0c0c0c'; ctx.fillRect(px,py+CFG.tileSize-3,CFG.tileSize,3); ctx.fillRect(px+CFG.tileSize-3,py,3,CFG.tileSize);
      ctx.fillStyle='#000'; ctx.fillRect(px+10,py+10,2,2); ctx.fillRect(px+26,py+26,2,2);
      ctx.fillStyle='rgba(255,255,255,0.05)'; ctx.fillRect(px+12,py+12,1,1);
    }else if(tile===2){
      ctx.fillStyle='#4a3b2a'; ctx.fillRect(px+2,py+2,CFG.tileSize-4,CFG.tileSize-4);
      ctx.strokeStyle='#2e241a'; ctx.lineWidth=2; ctx.strokeRect(px+4,py+4,CFG.tileSize-8,CFG.tileSize-8);
      ctx.beginPath(); ctx.moveTo(px+2,py+2); ctx.lineTo(px+38,py+38); ctx.moveTo(px+38,py+2); ctx.lineTo(px+2,py+38); ctx.stroke();
      ctx.fillStyle='rgba(0,0,0,0.20)'; ctx.fillRect(px+10,py+18,3,3); ctx.fillRect(px+24,py+26,2,2);
    }else{
      ctx.fillStyle='#050505'; ctx.fillRect(px,py,CFG.tileSize,CFG.tileSize);
      ctx.strokeStyle='#0f0f0f'; ctx.lineWidth=1; ctx.strokeRect(px,py,CFG.tileSize,CFG.tileSize);
      if((x+y)%7===0){ ctx.fillStyle='#151515'; ctx.fillRect(px+10,py+20,2,2); }
    }
  }

  clearZone(cx,cy,r){
    for(let y=cy;y<cy+r;y++){
      for(let x=cx;x<cx+r;x++){
        if(x<=0||x>=CFG.mapWidth-1||y<=0||y>=CFG.mapHeight-1) continue;
        if(this.map[y] && this.map[y][x]!==undefined) this.map[y][x]=0;
      }
    }
  }

  destroyTiles3x3(worldX, worldY){
    const tx=Math.floor(worldX/CFG.tileSize), ty=Math.floor(worldY/CFG.tileSize);
    for(let yy=ty-1; yy<=ty+1; yy++){
      for(let xx=tx-1; xx<=tx+1; xx++){
        if(xx<=0||xx>=CFG.mapWidth-1||yy<=0||yy>=CFG.mapHeight-1) continue;
        if(this.map[yy][xx]>0){
          this.map[yy][xx]=0;
          this.drawTileToBg(xx,yy,0);
        }
      }
    }
  }

  isValidSpawn(x,y){
    const tx=Math.floor(x/CFG.tileSize), ty=Math.floor(y/CFG.tileSize);
    if(tx<0||tx>=CFG.mapWidth||ty<0||ty>=CFG.mapHeight) return false;
    if(this.map[ty][tx]>0) return false;
    for(const t of this.tanks){
      if(MathUtils.dist(x,y,t.x,t.y) < CFG.tankRadius*2.5) return false;
    }
    return true;
  }
  findSafeSpawn(baseX,baseY){
    if(this.isValidSpawn(baseX,baseY)) return {x:baseX,y:baseY};
    let ang=0, dist=10;
    for(let i=0;i<60;i++){
      const tx=baseX+Math.cos(ang)*dist;
      const ty=baseY+Math.sin(ang)*dist;
      if(this.isValidSpawn(tx,ty)) return {x:tx,y:ty};
      ang+=0.45; dist+=5;
    }
    return {x:baseX,y:baseY};
  }

  spawnUnits(){
    this.tanks=[]; this.jets=[];
    this.bullets=[]; this.airBullets=[];
    this.missiles=[]; this.bombs=[]; this.aaMissiles=[];
    this.particles=[]; this.smokes=[]; this.fx=[];
    this.radarAlerts=[]; this.supportSignals=[];
    this.dangerZones=[];
    this.radarMemory=[];
    this.customRallyPoint=null;
    this.activeCommand=null;
    this.aaStrike={active:false,targetTeam:null,spawned:false};
    this.gameOver=false;
    this.spectating=false;
    this.cameraTarget=null;
    this.player=null;
    this.deathMenuOpen=false;
    this.markAge=0;

    this.searchOp=null;
    this.searchRallyPoint=null;
    this.engageTimer={1:0,2:0};
    this.offerSwitchDone=false;
    this.offerSwitchDeclined=false;
    document.getElementById("switchToJetMenu").style.display="none";

    document.getElementById('spectateMsg').style.display='none';
    document.getElementById('spectatorControls').style.display='none';
    document.getElementById('deathMenu').style.display='none';
    document.getElementById("radarClearBtn").style.display="none";

    const startX=250, startY=250;
    const enemyStartX=(CFG.mapWidth*CFG.tileSize)-250;
    const enemyStartY=(CFG.mapHeight*CFG.tileSize)-250;

    for(let i=0;i<this.blueTankCount;i++){
      let base={x:startX+(i%4)*60, y:startY+Math.floor(i/4)*60};
      let pos=this.findSafeSpawn(base.x,base.y);
      const isPlayer=(i===0 && this.playerPick==="TANK");
      let t=new Tank(this,pos.x,pos.y,CFG.teams.BLUE,isPlayer);
      this.tanks.push(t);
      if(isPlayer) this.player=t;
    }
    for(let i=0;i<this.blueJetCount;i++){
      const px=startX+(i%4)*70, py=startY+Math.floor(i/4)*70;
      const isPlayer=(!this.player && this.playerPick==="JET" && i===0);
      let j=new Jet(this,px,py,CFG.teams.BLUE,isPlayer);
      this.jets.push(j);
      if(isPlayer) this.player=j;
    }

    for(let i=0;i<this.redTankCount;i++){
      let base={x:enemyStartX-(i%4)*60, y:enemyStartY-Math.floor(i/4)*60};
      let pos=this.findSafeSpawn(base.x,base.y);
      this.tanks.push(new Tank(this,pos.x,pos.y,CFG.teams.RED,false));
    }
    for(let i=0;i<this.redJetCount;i++){
      const px=enemyStartX-(i%4)*70, py=enemyStartY-Math.floor(i/4)*70;
      this.jets.push(new Jet(this,px,py,CFG.teams.RED,false));
    }

    if(!this.player){
      const t=this.tanks.find(u=>u.team===CFG.teams.BLUE && !u.dead && !u.isWreckage);
      if(t){ t.isPlayer=true; t.ai=null; this.player=t; this.playerPick="TANK"; }
    }
  }

  bindControls(){
    window.addEventListener('keydown', e=>{
      this.keys[e.code]=true;
      if(e.code==='Digit1') this.useSkill(1);
      if(e.code==='Digit2') this.useSkill(2);
      if(e.code==='Tab'){ e.preventDefault(); this.toggleMenuPC(); }
      if(this.menuOpen && e.code==='Enter'){ e.preventDefault(); this.executePCCommand(); }
      if(e.code==='KeyN' && this.mouseOnRadar) this.handleRadarClick(false);
      if(e.code==='KeyT' && this.spectating) this.handleTakeOver();
    });
    window.addEventListener('keyup', e=>this.keys[e.code]=false);
    window.addEventListener('mousedown', ()=>this.keys['MouseLeft']=true);
    window.addEventListener('mouseup', ()=>this.keys['MouseLeft']=false);

    const menuItems=document.querySelectorAll('.cmd-item');
    menuItems.forEach((item,index)=>{
      item.addEventListener('mouseenter', ()=>{ this.selectedCmdIndex=index; this.updateMenuHighlight(); });
      item.addEventListener('click', ()=>{ this.selectedCmdIndex=index; this.executePCCommand(); });
    });

    this.radarCanvas.addEventListener('mousemove', e=>{
      const rect=this.radarCanvas.getBoundingClientRect();
      this.radarMousePos.x=e.clientX-rect.left; this.radarMousePos.y=e.clientY-rect.top;
      this.mouseOnRadar=true;
      document.getElementById('radarTooltip').style.display='block';
    });
    this.radarCanvas.addEventListener('mouseleave', ()=>{
      this.mouseOnRadar=false;
      document.getElementById('radarTooltip').style.display='none';
    });

    this.radarCanvas.addEventListener('touchstart', (e)=>{
      if(this.gameOver) return;
      e.preventDefault();
      const rect=this.radarCanvas.getBoundingClientRect();
      const t=e.changedTouches[0];
      this.radarMousePos.x=t.clientX-rect.left;
      this.radarMousePos.y=t.clientY-rect.top;
      this.handleRadarClick(true);
    }, {passive:false});

    document.getElementById("radarClearBtn").addEventListener("touchstart", (e)=>{
      e.preventDefault();
      this.clearRallyPoint(true);
    }, {passive:false});
    document.getElementById("radarClearBtn").addEventListener("click", ()=>this.clearRallyPoint(true));

    this.setupMobileControls();

    // Fix 3: Robust Spectator switching for mobile
    this.canvas.addEventListener('click', ()=>{
      if(this.spectating && !this.gameOver) this.switchSpectateTarget();
    });
    this.canvas.addEventListener('touchstart', (e)=>{
      if(this.spectating && !this.gameOver){
         // If touching UI controls, ignore. But canvas click covers screen.
         // We'll rely on a specific button or clean touch.
         // A simple full screen tap works too.
         this.switchSpectateTarget();
      }
    }, {passive:true});

    // Mobile spectate button
    const mobNext = document.getElementById("mobileSpectateNext");
    if(mobNext){
        mobNext.addEventListener("touchstart", (e)=>{
            e.preventDefault();
            e.stopPropagation();
            this.switchSpectateTarget();
        }, {passive:false});
    }

    document.getElementById('mobileCmdBtn').addEventListener('touchstart', (e)=>{
      e.preventDefault(); e.stopPropagation();
      if(!this.canIssueCommands()) return;
      const menu=document.getElementById('mobileCmdMenu');
      menu.style.display=(menu.style.display==='flex')?'none':'flex';
    }, {passive:false});

    document.querySelectorAll('.m-cmd-item').forEach(item=>{
      item.addEventListener('touchstart', (e)=>{
        e.preventDefault();
        if(!this.canIssueCommands()) return;
        const cmd=item.dataset.cmd;
        this.executeCommand(cmd);
        document.getElementById('mobileCmdMenu').style.display='none';
      }, {passive:false});
    });

    const takeOverBtn = document.querySelector("#spectatorControls button");
    if(takeOverBtn){
      takeOverBtn.addEventListener("touchstart", (e)=>{
        e.preventDefault();
        this.handleTakeOver();
      }, {passive:false});
    }
  }

  setupMobileControls(){
    const stick=document.getElementById('stick');
    const zone=document.getElementById('joystickZone');
    let startX=0,startY=0;

    zone.addEventListener('touchstart', e=>{
      e.preventDefault();
      const touch=e.changedTouches[0];
      startX=touch.clientX; startY=touch.clientY;
      stick.style.transition='none';
    }, {passive:false});
    zone.addEventListener('touchmove', e=>{
      e.preventDefault();
      const touch=e.changedTouches[0];
      let dx=touch.clientX-startX, dy=touch.clientY-startY;
      const dist=Math.hypot(dx,dy);
      const maxDist=35;
      if(dist>maxDist){ dx=(dx/dist)*maxDist; dy=(dy/dist)*maxDist; }
      stick.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      this.touchInput.x=dx/maxDist; this.touchInput.y=dy/maxDist;
    }, {passive:false});
    zone.addEventListener('touchend', ()=>{
      stick.style.transition='0.2s';
      stick.style.transform='translate(-50%, -50%)';
      this.touchInput.x=0; this.touchInput.y=0;
    });

    document.querySelectorAll('.skill-btn').forEach(btn=>{
      btn.addEventListener('touchstart', e=>{
        e.preventDefault();
        const key=btn.dataset.key;
        if(key==='SPACE') this.touchInput.shooting=true;
        else this.useSkill(parseInt(key));
      }, {passive:false});
      btn.addEventListener('touchend', e=>{
        e.preventDefault();
        if(btn.dataset.key==='SPACE') this.touchInput.shooting=false;
      }, {passive:false});
    });
  }

  canIssueCommands(){
    if(this.player && !this.player.dead && !this.player.isWreckage) return true;
    return false;
  }

  toggleMenuPC(){
    if(!this.canIssueCommands()) return;
    this.menuOpen=!this.menuOpen;
    document.getElementById('commandMenuPC').style.display=this.menuOpen?'block':'none';
  }
  updateMenuHighlight(){
    const list=document.querySelectorAll('#pcCmdList .cmd-item');
    list.forEach((item,idx)=>{ (idx===this.selectedCmdIndex)?item.classList.add('active'):item.classList.remove('active'); });
  }
  executePCCommand(){
    if(!this.canIssueCommands()) return;
    const list=document.querySelectorAll('#pcCmdList .cmd-item');
    const cmd=list[this.selectedCmdIndex].dataset.cmd;
    this.executeCommand(cmd);
    this.toggleMenuPC();
  }

  clearRallyPoint(showToast){
    this.customRallyPoint=null;
    this.activeCommand=null;
    this.markAge=0;
    document.getElementById("radarClearBtn").style.display="none";
    if(showToast){ this.showMessage("æˆ˜æœ¯æ ‡è®°å·²æ¸…é™¤"); AudioSys.sfxCmd(); }
  }

  handleRadarClick(fromTouch){
    const scale=this.radarCanvas.width/(CFG.mapWidth*CFG.tileSize);

    if(this.customRallyPoint && !fromTouch){
      const rX=this.customRallyPoint.x*scale, rY=this.customRallyPoint.y*scale;
      if(Math.hypot(this.radarMousePos.x-rX, this.radarMousePos.y-rY) < 15){
        this.clearRallyPoint(true);
        return;
      }
    }

    const worldX=this.radarMousePos.x/scale;
    const worldY=this.radarMousePos.y/scale;
    this.customRallyPoint={x:worldX,y:worldY};
    this.markAge=0;
    this.activeCommand='RALLY_POINT';
    this.showMessage("æŒ‡ä»¤: å…¨é˜Ÿç§»åŠ¨è‡³æ ‡è®°ç‚¹");
    AudioSys.sfxCmd();
    this.fx.push(new Shockwave(worldX,worldY,'#4af626'));
    document.getElementById("radarClearBtn").style.display="block";

    this.assignNearestJetStrike(CFG.teams.BLUE, this.customRallyPoint.x, this.customRallyPoint.y, "MARK");
  }

  executeCommand(cmdType){
    if(!this.canIssueCommands()) return;

    if(cmdType==='RALLY'){ this.customRallyPoint=null; this.activeCommand='RALLY'; this.markAge=0; }
    else if(cmdType==='SCATTER'){ this.customRallyPoint=null; this.activeCommand='SCATTER'; this.markAge=0; }
    else if(cmdType==='SEARCH'){ this.customRallyPoint=null; this.activeCommand='SEARCH'; this.markAge=0; }
    else if(cmdType==='SQUAD_SMOKE'){ this.activeCommand='SQUAD_SMOKE'; this.markAge=0; }
    else if(cmdType==='SQUAD_EMP'){ this.activeCommand='SQUAD_EMP'; this.markAge=0; }

    this.showMessage("æŒ‡ä»¤: "+this.getCmdName(cmdType));
    AudioSys.sfxCmd();

    const origin=this.player||this.cameraTarget||{x:0,y:0};
    const color=(cmdType==='SCATTER' || cmdType==='SEARCH')?'#ffb000':'#4af626';
    this.fx.push(new Shockwave(origin.x,origin.y,color));

    const commander=(this.player && this.player.type==="TANK")?this.player:(this.tanks.find(t=>!t.dead && t.team===CFG.teams.BLUE) || this.cameraTarget || null);

    this.tanks.forEach(t=>{
      if(t.team===CFG.teams.BLUE && !t.isPlayer && !t.dead && t.ai){
        t.ai.receiveCommand(cmdType, commander);
      }
    });

    if(cmdType==='SEARCH'){
      this.startSearchOp();
    }
  }

  getCmdName(cmd){
    const map={RALLY:'å…¨å‘˜é›†åˆ',SCATTER:'åˆ†æ•£ç´¢æ•Œ',SEARCH:'æœç´¢',SQUAD_SMOKE:'éƒ¨ç½²çƒŸé›¾',SQUAD_EMP:'éœ‡è¡æ‰“å‡»',RALLY_POINT:'å‰å¾€æ ‡è®°'};
    return map[cmd]||cmd;
  }

  useSkill(idx){
    if(this.player && !this.player.dead) this.player.activateSkill(idx);
  }

  markEngagement(team, seconds=2.2){
    this.engageTimer[team]=Math.max(this.engageTimer[team]||0, seconds);
  }
  isTeamEngaged(team){
    return (this.engageTimer[team]||0) > 0.001;
  }

  broadcastSupport(x,y,team,kind="FIRE"){
    const g=this;
    const enemyTeam=(team===CFG.teams.BLUE)?CFG.teams.RED:CFG.teams.BLUE;

    const hasEnemyNearby = ()=>{
      for(const t of g.tanks){
        if(t.team===enemyTeam && !t.dead && !t.isWreckage){
          if(MathUtils.dist(x,y,t.x,t.y)<CFG.visionDist*1.1) return true;
        }
      }
      for(const j of g.jets){
        if(j.team===enemyTeam && !j.dead && !j.isWreckage && !j.crashing){
          if(MathUtils.dist(x,y,j.x,j.y)<CFG.jetVision*1.1) return true;
        }
      }
      return false;
    };

    if(["FIRE","CONTACT","RECON"].includes(kind)){
      if(!hasEnemyNearby()) return;
      this.markEngagement(team, 2.4);
    }
    if(kind==="HIT" || kind==="ALLY_DOWN"){
      this.markEngagement(team, 3.0);
    }

    this.supportSignals.push({x,y,team,kind,life:2.6,ts:Date.now()});
    this.radarAlerts.push({x,y,team,life:1.0});

    this.tanks.forEach(t=>{
      if(t.team===team && !t.dead && !t.isWreckage && t.ai && !t.isPlayer){
        t.ai.onSupportSignal(x,y,kind);
      }
    });
    this.jets.forEach(j=>{
      if(j.team===team && !j.dead && !j.isWreckage && j.ai && !j.isPlayer){
        j.ai.onSupportSignal(x,y,kind);
      }
    });
  }

  assignNearestJetStrike(team,x,y,kind="MARK"){
    const jets=this.jets.filter(j=>j.team===team && !j.dead && !j.isWreckage && j.ai);
    if(!jets.length) return;
    let best=null, bestD=Infinity;
    for(const j of jets){
      const d=MathUtils.dist(j.x,j.y,x,y);
      if(d<bestD){ bestD=d; best=j; }
    }
    if(best) best.ai.setTask(x,y,kind,4.5);
  }

  addDangerZone(x,y,r,team,ttl){
    this.dangerZones.push({x,y,r,team,ttl});
  }

  startSearchOp(){
    if(this.searchOp && !this.searchOp.done) { this.showMessage("æœç´¢æ­£åœ¨æ‰§è¡Œ"); return; }
    const candidates=this.jets.filter(j=>j.team===CFG.teams.BLUE && !j.dead && !j.isWreckage && j.ai && !j.isPlayer);
    if(!candidates.length){ this.showMessage("æ— å¯ç”¨æˆ˜æ–—æœºæ‰§è¡Œæœç´¢"); return; }

    const cen=this.getJetSquadCenter(CFG.teams.BLUE);
    let best=null, bestD=Infinity;
    for(const j of candidates){
      const d=MathUtils.dist(j.x,j.y,cen.x,cen.y);
      if(d<bestD){ bestD=d; best=j; }
    }
    if(!best) return;
    this.searchOp={phase:'SEARCH', scoutId:best.id, targetId:null, tx:0, ty:0, tSeen:0, done:false, called:false};
    this.searchRallyPoint=null;
    best.ai.beginSearch();
    this.showMessage("æœç´¢å·²å¯åŠ¨ï¼šä¾¦æœæœºå‡ºåˆ—");
  }

  updateSearchOp(dt){
    if(!this.searchOp || this.searchOp.done) return;
    const op=this.searchOp;
    const scout=this.jets.find(j=>j.id===op.scoutId && !j.dead && !j.isWreckage);
    if(!scout || !scout.ai){ op.done=true; this.searchRallyPoint=null; return; }

    const enemyTeam=CFG.teams.RED;
    const enemies=[...this.tanks.filter(t=>t.team===enemyTeam && !t.dead && !t.isWreckage),
                   ...this.jets.filter(j=>j.team===enemyTeam && !j.dead && !j.isWreckage && !j.crashing)];
    let found=null, bestD=Infinity;
    for(const e of enemies){
      const d=MathUtils.dist(scout.x,scout.y,e.x,e.y);
      if(d<bestD && d<CFG.jetVision*0.95){
        if(e.type==="TANK"){
          if(this.isPosInSmoke(e.x,e.y)) continue;
          if(!this.checkLineOfSight(scout.x,scout.y,e.x,e.y)) continue;
        }
        bestD=d; found=e;
      }
    }

    if(op.phase==='SEARCH'){
      if(found){
        op.phase='TRACK';
        op.targetId=found.id;
        op.tx=found.x; op.ty=found.y;
        op.tSeen=2.5;
        op.called=false;
        this.searchRallyPoint={x:found.x,y:found.y};
        scout.ai.beginTrack(found);
        this.callGroundToSearchPoint();
        this.showMessage("æœç´¢ï¼šå‘ç°ç›®æ ‡ï¼åœ°é¢é›†ç»“ä¸­");
        AudioSys.sfxCmd();
      }
      return;
    }

    if(op.phase==='TRACK'){
      const targ = enemies.find(e=>e.id===op.targetId) || found;
      if(targ){
        op.tx=targ.x; op.ty=targ.y;
        op.tSeen=Math.min(2.5, op.tSeen+dt*0.8);
        this.searchRallyPoint={x:op.tx,y:op.ty};
        scout.ai.updateTrackPoint(op.tx, op.ty, targ);
        const others=this.jets.filter(j=>j.team===CFG.teams.BLUE && !j.dead && !j.isWreckage && j.ai && j.id!==scout.id);
        for(const j of others){
          if(Math.random()<0.08) j.ai.setOverwatch(op.tx, op.ty);
        }
        if(Math.random()<0.10){
          this.broadcastSupport(op.tx,op.ty,CFG.teams.BLUE,"RECON");
        }
      }else{
        op.tSeen -= dt;
        if(op.tSeen<=0){
          op.phase='SEARCH';
          op.targetId=null;
          this.searchRallyPoint=null;
          scout.ai.beginSearch();
          this.showMessage("æœç´¢ï¼šç›®æ ‡ä¸¢å¤±ï¼Œç»§ç»­æ‰«æ");
        }
      }

      if(this.searchRallyPoint){
        const p=this.searchRallyPoint;
        const allies=this.tanks.filter(t=>t.team===CFG.teams.BLUE && !t.dead && !t.isWreckage);
        const near=allies.filter(t=>MathUtils.dist(t.x,t.y,p.x,p.y)<240).length;
        const need=Math.max(2, Math.ceil(allies.length*0.45));
        if(allies.length>0 && near>=need){
          op.phase='RETURN';
          scout.ai.beginReturn();
          this.showMessage("æœç´¢ï¼šåœ°é¢å·²æ¥è§¦ï¼Œä¾¦æœæœºè¿”èˆªå½’é˜Ÿ");
        }
      }
      return;
    }

    if(op.phase==='RETURN'){
      const cen=this.getJetSquadCenter(CFG.teams.BLUE);
      const d=MathUtils.dist(scout.x,scout.y,cen.x,cen.y);
      if(d<220){
        op.done=true;
        this.searchRallyPoint=null;
        scout.ai.endSearch();
      }
    }
  }

  callGroundToSearchPoint(){
    if(!this.searchRallyPoint) return;
    const p=this.searchRallyPoint;
    this.markEngagement(CFG.teams.BLUE, 3.2);
    const commander=(this.player && this.player.type==="TANK")?this.player:(this.tanks.find(t=>!t.dead && t.team===CFG.teams.BLUE) || null);
    this.tanks.forEach(t=>{
      if(t.team===CFG.teams.BLUE && !t.dead && !t.isWreckage && t.ai && !t.isPlayer){
        t.ai.receiveSearchTarget(p.x,p.y, commander);
      }
    });
  }

  getJetSquadCenter(team){
    const jets=this.jets.filter(j=>j.team===team && !j.dead && !j.isWreckage);
    if(!jets.length) return {x:CFG.mapWidth*CFG.tileSize/2,y:CFG.mapHeight*CFG.tileSize/2};
    let x=0,y=0;
    for(const j of jets){ x+=j.x; y+=j.y; }
    return {x:x/jets.length,y:y/jets.length};
  }

  handleTakeOver(){
    const ally=this.tanks.find(t=>t.team===CFG.teams.BLUE && !t.dead && !t.isPlayer && !t.isWreckage)
      || this.jets.find(j=>j.team===CFG.teams.BLUE && !j.dead && !j.isPlayer && !j.isWreckage);
    if(ally){
      this.tanks.forEach(t=>{ if(t.isPlayer) t.isPlayer=false; });
      this.jets.forEach(j=>{ if(j.isPlayer) j.isPlayer=false; });

      ally.isPlayer=true; ally.ai=null;
      this.player=ally; this.spectating=false; this.cameraTarget=null;
      document.getElementById('spectateMsg').style.display='none';
      document.getElementById('spectatorControls').style.display='none';
      document.getElementById('deathMenu').style.display='none';
      this.deathMenuOpen=false;
      this.showMessage("ç¥ç»é“¾è·¯å·²æ¥å…¥ - ç³»ç»Ÿæ­£å¸¸"); AudioSys.sfxCmd();
    }else this.showMessage("æ— å¯æ¥ç®¡å•ä½");
  }

  handleSpectate(){
    this.deathMenuOpen=false;
    document.getElementById('deathMenu').style.display='none';
    this.spectating=true;
    this.player=null;
    document.getElementById('spectateMsg').style.display='block';
    document.getElementById('spectatorControls').style.display='block';
    this.switchSpectateTarget();
    AudioSys.sfxCmd();
  }

  switchSpectateTarget(){
    const alive=[...this.tanks.filter(t=>!t.dead && !t.isWreckage), ...this.jets.filter(j=>!j.dead && !j.isWreckage)];
    if(alive.length){
      let idx=alive.indexOf(this.cameraTarget);
      if(idx===-1) idx=0;
      else idx = (idx+1)%alive.length;
      this.cameraTarget=alive[idx];
    }
  }

  acceptSwitchToJet(yes){
    document.getElementById("switchToJetMenu").style.display="none";
    this.offerSwitchDone=true;
    if(!yes){ this.offerSwitchDeclined=true; this.showMessage("å·²ä¿æŒå¦å…‹æ§åˆ¶"); return; }

    if(!this.player || this.player.dead || this.player.type!=="TANK") return;

    const candidate=this.jets.find(j=>j.team===CFG.teams.BLUE && !j.dead && !j.isWreckage && !j.isPlayer);
    if(!candidate){ this.showMessage("æ— å¯æ¥ç®¡æˆ˜æ–—æœº"); return; }

    const old=this.player;
    old.isPlayer=false;
    if(!old.ai) old.ai=new AIController(old);

    this.tanks.forEach(t=>{ if(t.isPlayer) t.isPlayer=false; });
    this.jets.forEach(j=>{ if(j.isPlayer) j.isPlayer=false; });

    candidate.isPlayer=true;
    candidate.ai=null;
    this.player=candidate;
    this.showMessage("åˆ‡æ¢æˆåŠŸï¼šå·²æ¥ç®¡æˆ˜æ–—æœº");
    AudioSys.sfxCmd();
  }

  loop(ts){
    let dt=(ts-this.lastTime)/1000;
    this.lastTime=ts;
    if(dt>0.1) dt=0.1;
    if(!this.gameOver) this.update(dt);
    this.draw();
    requestAnimationFrame(t=>this.loop(t));
  }

  update(dt){
    this.radarAngle=(this.radarAngle+(Math.PI*2/CFG.radarPeriod)*dt)%(Math.PI*2);

    this.engageTimer[CFG.teams.BLUE]=Math.max(0,(this.engageTimer[CFG.teams.BLUE]||0)-dt);
    this.engageTimer[CFG.teams.RED] =Math.max(0,(this.engageTimer[CFG.teams.RED] ||0)-dt);

    const target=this.player || this.cameraTarget;
    if(target){
      this.camera.x += (target.x - this.camera.x) * 0.1;
      this.camera.y += (target.y - this.camera.y) * 0.1;
      const targAng = -target.angle - Math.PI/2;
      this.cameraAngle = MathUtils.lerpAngle(this.cameraAngle, targAng, 0.05);
    }

    for(let i=this.dangerZones.length-1;i>=0;i--){
      this.dangerZones[i].ttl-=dt;
      if(this.dangerZones[i].ttl<=0) this.dangerZones.splice(i,1);
    }

    for(let i=this.supportSignals.length-1;i>=0;i--){
      this.supportSignals[i].life-=dt;
      if(this.supportSignals[i].life<=0) this.supportSignals.splice(i,1);
    }

    this.tanks.forEach(t=>t.update(dt));
    this.jets.forEach(j=>j.update(dt));

    for(let i=this.bullets.length-1;i>=0;i--){ this.bullets[i].update(dt); if(this.bullets[i].dead) this.bullets.splice(i,1); }
    for(let i=this.airBullets.length-1;i>=0;i--){ this.airBullets[i].update(dt); if(this.airBullets[i].dead) this.airBullets.splice(i,1); }
    for(let i=this.missiles.length-1;i>=0;i--){ this.missiles[i].update(dt); if(this.missiles[i].dead) this.missiles.splice(i,1); }
    for(let i=this.bombs.length-1;i>=0;i--){ this.bombs[i].update(dt); if(this.bombs[i].dead) this.bombs.splice(i,1); }
    for(let i=this.aaMissiles.length-1;i>=0;i--){ this.aaMissiles[i].update(dt); if(this.aaMissiles[i].dead) this.aaMissiles.splice(i,1); }

    for(let i=this.particles.length-1;i>=0;i--){ this.particles[i].update(dt); if(this.particles[i].life<=0) this.particles.splice(i,1); }
    for(let i=this.smokes.length-1;i>=0;i--){ this.smokes[i].update(dt); if(this.smokes[i].life<=0) this.smokes.splice(i,1); }
    for(let i=this.fx.length-1;i>=0;i--){ this.fx[i].update(dt); if(this.fx[i].done) this.fx.splice(i,1); }
    for(let i=this.radarAlerts.length-1;i>=0;i--){ this.radarAlerts[i].life-=dt; if(this.radarAlerts[i].life<=0) this.radarAlerts.splice(i,1); }

    this.updateSearchOp(dt);

    if(this.customRallyPoint && !this.gameOver){
      this.markAge += dt;
      if(this.markAge > 1.4){
        const r=260;
        const nearCnt = (team)=>{
          let c=0;
          for(const t of this.tanks) if(t.team===team && !t.dead && !t.isWreckage && MathUtils.dist(t.x,t.y,this.customRallyPoint.x,this.customRallyPoint.y)<r) c++;
          for(const j of this.jets) if(j.team===team && !j.dead && !j.isWreckage && MathUtils.dist(j.x,j.y,this.customRallyPoint.x,this.customRallyPoint.y)<r) c++;
          return c;
        };
        const b=nearCnt(CFG.teams.BLUE), rr=nearCnt(CFG.teams.RED);
        const total=b+rr;
        const balanced = total>=4 && Math.abs(b-rr)<=1;
        if(balanced){
          this.clearRallyPoint(false);
          this.showMessage("æ ‡ç‚¹å®Œæˆï¼šåŒæ–¹å·²æ¥è§¦ - æ ‡è®°è‡ªåŠ¨æ¸…é™¤");
          AudioSys.sfxCmd();
        }
      }
    }

    if(this.customRallyPoint && this.activeCommand==='RALLY_POINT'){
      const squad=this.tanks.filter(t=>t.team===CFG.teams.BLUE && !t.dead && !t.isWreckage && t.ai && t.ai.state==='COMMAND_EXEC');
      if(squad.length){
        let cx=0, cy=0;
        squad.forEach(t=>{ cx+=t.x; cy+=t.y; });
        cx/=squad.length; cy/=squad.length;
        if(MathUtils.dist(cx,cy,this.customRallyPoint.x,this.customRallyPoint.y)<150){
          squad.forEach(t=>t.ai.state='IDLE');
          this.activeCommand=null;
        }
      }
    }

    const c=this.getAliveCounts();
    this.handleAaRule(c);

    if(!this.gameOver && !this.offerSwitchDone && !this.offerSwitchDeclined){
      if(this.player && !this.player.dead && this.player.type==="TANK"){
        const enemyJetsLeft=c.redJet;
        const bothHaveTanks=(c.blueTank>0 && c.redTank>0);
        const haveBlueJets=c.blueJet>0;
        if(enemyJetsLeft===0 && bothHaveTanks && haveBlueJets){
          this.offerSwitchDone=true;
          document.getElementById("switchToJetMenu").style.display="block";
        }
      }
    }

    this.uiTimer -= dt;
    if(this.uiTimer<=0){
      this.uiTimer=0.08;
      document.getElementById('teamCount').innerText=c.blueTotal;
      document.getElementById('enemyCount').innerText=c.redTotal;

      if(this.player && !this.player.dead){
        const p=this.player;
        document.getElementById('hpBar').style.width=(p.hp/p.maxHp*100)+'%';
        const fireMax=(p.type==="JET")?CFG.jetGunRate:CFG.fireRate;
        document.getElementById('cdBar').style.width=(100 - (p.shootTimer / fireMax * 100))+'%';
        document.getElementById("pcCd1").innerText=(p.skillCD && p.skillCD[1] ? Math.max(0,p.skillCD[1]).toFixed(1) : "0.0");
        document.getElementById("pcCd2").innerText=(p.skillCD && p.skillCD[2] ? Math.max(0,p.skillCD[2]).toFixed(1) : "0.0");
      }
    }

    if(this.player && this.player.dead && !this.deathMenuOpen && !this.spectating){
      const allies=[...this.tanks.filter(t=>t.team===CFG.teams.BLUE && !t.dead && !t.isWreckage && !t.isPlayer),
                    ...this.jets.filter(j=>j.team===CFG.teams.BLUE && !j.dead && !j.isWreckage && !j.isPlayer)];
      if(allies.length){
        this.deathMenuOpen=true;
        document.getElementById('deathMenu').style.display='block';
      }else this.handleSpectate();
    }

    if(this.aaStrike.active){
      const targetTeam=this.aaStrike.targetTeam;
      const jetsAlive=this.jets.filter(j=>j.team===targetTeam && !j.dead && !j.isWreckage).length;
      if(jetsAlive===0){
        const isBlueLose=(targetTeam===CFG.teams.BLUE);
        this.endGame(!isBlueLose);
      }
    }

    if(!this.gameOver && !this.aaStrike.active){
      if(c.blueTotal===0 || c.redTotal===0){
        this.endGame(c.blueTotal>0);
      }
    }
  }

  getAliveCounts(){
    const blueTank=this.tanks.filter(t=>t.team===CFG.teams.BLUE && !t.dead && !t.isWreckage).length;
    const redTank=this.tanks.filter(t=>t.team===CFG.teams.RED && !t.dead && !t.isWreckage).length;
    const blueJet=this.jets.filter(j=>j.team===CFG.teams.BLUE && !j.dead && !j.isWreckage).length;
    const redJet=this.jets.filter(j=>j.team===CFG.teams.RED && !j.dead && !j.isWreckage).length;
    return {blueTank,redTank,blueJet,redJet, blueTotal:blueTank+blueJet, redTotal:redTank+redJet};
  }

  handleAaRule(c){
    const blueOnlyJets=(c.blueTank===0 && c.blueJet>0);
    const redOnlyJets=(c.redTank===0 && c.redJet>0);
    const blueNoJets=(c.blueJet===0);
    const redNoJets=(c.redJet===0);
    const redHasTanks=(c.redTank>0);
    const blueHasTanks=(c.blueTank>0);

    if(!this.aaStrike.active){
      if(blueOnlyJets && redNoJets && redHasTanks) this.triggerAaStrike(CFG.teams.BLUE);
      else if(redOnlyJets && blueNoJets && blueHasTanks) this.triggerAaStrike(CFG.teams.RED);
    }
  }

  triggerAaStrike(targetTeam){
    this.aaStrike.active=true; this.aaStrike.targetTeam=targetTeam; this.aaStrike.spawned=false;
    this.showMessage("âš  é˜²ç©ºç³»ç»Ÿé”å®šï¼šç©ºä¸­ä¼˜åŠ¿è¢«ååˆ¶"); AudioSys.sfxAa();
    const jets=this.jets.filter(j=>j.team===targetTeam && !j.dead && !j.isWreckage);
    for(const j of jets) this.aaMissiles.push(new AAMissile(this, j));
    this.aaStrike.spawned=true;
  }

  updateSkillUI(id,current,max){
    const el=document.querySelector(`#${id} .cooldown-overlay`);
    if(!el) return;
    if(current>0) el.style.height=((current/max)*100)+'%';
    else el.style.height='0%';
  }

  draw(){
    this.ctx.fillStyle='#050505';
    this.ctx.fillRect(0,0,this.width,this.height);

    this.ctx.save();
    const cx=this.width/2, cy=this.height/2;
    this.ctx.translate(cx,cy);
    this.ctx.rotate(this.cameraAngle);
    this.ctx.translate(-this.camera.x,-this.camera.y);

    this.ctx.drawImage(this.bgCanvas,0,0);

    this.tanks.forEach(t=>{ if(!t.dead) t.drawShadow(this.ctx); });
    this.particles.forEach(p=>p.draw(this.ctx));
    
    // Fix 1: Drawing Order - Ground Wrecks -> Ground Units -> Air Units
    // 1. Jet Wrecks (Ground level)
    this.jets.forEach(j=>{ if(j.isWreckage) j.draw(this.ctx); });
    
    // 2. Tanks
    this.tanks.forEach(t=>t.draw(this.ctx));
    
    this.bullets.forEach(b=>b.draw(this.ctx));
    this.smokes.forEach(s=>s.draw(this.ctx));
    this.fx.forEach(f=>f.draw(this.ctx));

    const camTarget=this.player||this.cameraTarget;
    const airAlpha=(camTarget && camTarget.type==="TANK")?0.30:1.0;
    this.ctx.save(); this.ctx.globalAlpha=airAlpha;
    
    // 3. Live Jets (Air level)
    this.jets.forEach(j=>{ if(!j.isWreckage) j.draw(this.ctx); });
    
    this.airBullets.forEach(b=>b.draw(this.ctx));
    this.missiles.forEach(m=>m.draw(this.ctx));
    this.bombs.forEach(b=>b.draw(this.ctx));
    this.aaMissiles.forEach(m=>m.draw(this.ctx));
    this.ctx.restore();

    if(this.customRallyPoint && !this.gameOver){
      const mx=this.customRallyPoint.x, my=this.customRallyPoint.y;
      this.ctx.strokeStyle='rgba(74,246,38,0.55)';
      this.ctx.lineWidth=2;
      this.ctx.beginPath();
      this.ctx.moveTo(mx-10,my); this.ctx.lineTo(mx+10,my);
      this.ctx.moveTo(mx,my-10); this.ctx.lineTo(mx,my+10);
      this.ctx.stroke();
    }

    if(this.searchRallyPoint && !this.gameOver){
      const p=this.searchRallyPoint;
      this.ctx.strokeStyle='rgba(255,176,0,0.65)';
      this.ctx.lineWidth=2;
      this.ctx.beginPath();
      this.ctx.arc(p.x,p.y,14,0,Math.PI*2); this.ctx.stroke();
      this.ctx.beginPath();
      this.ctx.moveTo(p.x-12,p.y); this.ctx.lineTo(p.x+12,p.y);
      this.ctx.moveTo(p.x,p.y-12); this.ctx.lineTo(p.x,p.y+12);
      this.ctx.stroke();
    }

    for(const dz of this.dangerZones){
      if(dz.team===CFG.teams.BLUE){
        this.ctx.strokeStyle='rgba(255,51,51,0.10)';
        this.ctx.lineWidth=2;
        this.ctx.beginPath();
        this.ctx.arc(dz.x,dz.y,dz.r,0,Math.PI*2);
        this.ctx.stroke();
      }
    }

    this.ctx.restore();

    this.drawRadar();
    this.updateMobileSkillLabels();
  }

  updateMobileSkillLabels(){
    const s1=document.getElementById("btnSkill1");
    const s2=document.getElementById("btnSkill2");
    const shoot=document.getElementById("btnShoot");
    if(!this.player || this.player.dead) return;
    const setText = (el, txt)=>{
      for(const n of el.childNodes){
        if(n.nodeType===3){ n.nodeValue = txt; return; }
      }
    };
    if(this.player.type==="JET"){
      setText(s1,"å¯¼å¼¹"); setText(s2,"æŠ•å¼¹"); setText(shoot,"ç©ºæˆ˜");
    }else{
      setText(s1,"çƒŸé›¾"); setText(s2,"éœ‡è¡"); setText(shoot,"å¼€ç«");
    }
  }

  drawRadar(){
    const ctx=this.radarCtx;
    const w=this.radarCanvas.width, h=this.radarCanvas.height;
    const cx=w/2, cy=h/2;
    const scale=w/(CFG.mapWidth*CFG.tileSize);
    ctx.clearRect(0,0,w,h);

    ctx.strokeStyle='rgba(74,246,38,0.3)'; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(w,cy); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,h); ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,w*0.2,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,w*0.4,0,Math.PI*2); ctx.stroke();

    const viewTeam=CFG.teams.BLUE;

    this.radarAlerts.forEach(a=>{
      if(a.team===viewTeam){
        const ax=a.x*scale, ay=a.y*scale;
        ctx.strokeStyle=`rgba(255,51,51,${a.life})`;
        ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(ax,ay,(1.0-a.life)*20,0,Math.PI*2); ctx.stroke();
      }
    });

    if(this.customRallyPoint){
      const rx=this.customRallyPoint.x*scale, ry=this.customRallyPoint.y*scale;
      ctx.strokeStyle='#4af626'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(rx-4,ry); ctx.lineTo(rx+4,ry);
      ctx.moveTo(rx,ry-4); ctx.lineTo(rx,ry+4);
      ctx.stroke();
    }
    if(this.searchRallyPoint){
      const rx=this.searchRallyPoint.x*scale, ry=this.searchRallyPoint.y*scale;
      ctx.strokeStyle='#ffb000'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.arc(rx,ry,6,0,Math.PI*2); ctx.stroke();
    }

    const drawTankIcon=(x,y,ang,color,isPlayer=false)=>{
      ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
      ctx.fillStyle=color;
      ctx.beginPath(); ctx.moveTo(4,0); ctx.lineTo(-3,3); ctx.lineTo(-3,-3); ctx.fill();
      ctx.fillRect(-5,-1,2,2);
      if(isPlayer){ ctx.strokeStyle='#ffb000'; ctx.lineWidth=1; ctx.strokeRect(-6,-6,12,12); }
      ctx.restore();
    };
    const drawJetIcon=(x,y,ang,color,isPlayer=false)=>{
      ctx.save(); ctx.translate(x,y); ctx.rotate(ang);
      ctx.fillStyle=color;
      ctx.beginPath();
      ctx.moveTo(5,0);
      ctx.lineTo(0,3);
      ctx.lineTo(-4,0);
      ctx.lineTo(0,-3);
      ctx.closePath();
      ctx.fill();
      ctx.fillRect(-1,-1,2,2);
      if(isPlayer){ ctx.strokeStyle='#ffb000'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2); ctx.stroke(); }
      ctx.restore();
    };

    this.tanks.forEach(t=>{
      if(t.dead) return;
      const tX=t.x*scale, tY=t.y*scale;
      if(t.isWreckage){
        ctx.save(); ctx.translate(tX,tY); ctx.rotate(t.angle);
        ctx.fillStyle='#555'; ctx.fillRect(-2,-2,4,4);
        ctx.restore();
        return;
      }
      if(t.team===viewTeam){
        const col=t.isPlayer?'#ffb000':'#4af626';
        drawTankIcon(tX,tY,t.angle,col,t.isPlayer);
      }else{
        const dx=t.x-(CFG.mapWidth*CFG.tileSize/2);
        const dy=t.y-(CFG.mapHeight*CFG.tileSize/2);
        let ang=Math.atan2(dy,dx); if(ang<0) ang+=Math.PI*2;
        if(!t.isDisabled && !this.isPosInSmoke(t.x,t.y)){
          const diff=Math.abs(ang-this.radarAngle);
          if(diff<0.2){
            let mem=this.radarMemory.find(m=>m.id===t.id);
            if(!mem){ mem={id:t.id, kind:"TANK"}; this.radarMemory.push(mem); }
            mem.x=t.x; mem.y=t.y; mem.angle=t.angle; mem.time=Date.now(); mem.kind="TANK";
          }
        }
      }
    });

    this.jets.forEach(j=>{
      if(j.dead || j.isWreckage) return;
      const jX=j.x*scale, jY=j.y*scale;
      if(j.team===viewTeam){
        const col=j.isPlayer?'#ffb000':'#4af626';
        drawJetIcon(jX,jY,j.angle,col,j.isPlayer);
      }else{
        drawJetIcon(jX,jY,j.angle,'#ff3333',false);
      }
    });

    const now=Date.now();
    for(let i=this.radarMemory.length-1;i>=0;i--){
      const m=this.radarMemory[i];
      const real=this.tanks.find(t=>t.id===m.id);
      if(!real || real.dead || real.isWreckage){ this.radarMemory.splice(i,1); continue; }
      const age=(now-m.time)/1000;
      if(age>4){ this.radarMemory.splice(i,1); continue; }
      const mx=m.x*scale, my=m.y*scale;
      ctx.globalAlpha=Math.max(0,1-age/4);
      drawTankIcon(mx,my,m.angle,'#ff3333',false);
      ctx.globalAlpha=1.0;
    }

    ctx.strokeStyle='rgba(74,246,38,0.9)'; ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.lineTo(cx+Math.cos(this.radarAngle)*w, cy+Math.sin(this.radarAngle)*h);
    ctx.stroke();
  }

  isPosInSmoke(x,y){
    return this.smokes.some(s=>MathUtils.dist(x,y,s.x,s.y)<s.radius);
  }

  checkLineOfSight(x1,y1,x2,y2){
    if(this.smokes.some(s=>MathUtils.lineIntersectsCircle(x1,y1,x2,y2,s.x,s.y,s.radius))) return false;
    const dist=MathUtils.dist(x1,y1,x2,y2);
    const steps=dist/(CFG.tileSize/2) || 1;
    const dx=(x2-x1)/steps, dy=(y2-y1)/steps;
    let cx=x1, cy=y1;
    for(let i=0;i<steps;i++){
      cx+=dx; cy+=dy;
      const tx=Math.floor(cx/CFG.tileSize), ty=Math.floor(cy/CFG.tileSize);
      if(this.map[ty] && this.map[ty][tx]>0) return false;
      for(const t of this.tanks){
        if(t.isWreckage && MathUtils.dist(cx,cy,t.x,t.y)<t.radius) return false;
      }
    }
    return true;
  }

  endGame(isWin){
    this.gameOver=true;
    this.deathMenuOpen=false;
    AudioSys.stop();
    document.getElementById('deathMenu').style.display='none';
    document.getElementById('spectatorControls').style.display='none';
    document.getElementById("switchToJetMenu").style.display="none";
    const modal=document.getElementById('modal');
    modal.style.display='block';
    document.getElementById('resultTitle').innerText=isWin?"ä»»åŠ¡å®Œæˆ":"ä»»åŠ¡å¤±è´¥";
    document.getElementById('resultTitle').style.color=isWin?"#4af626":"#ff3333";
    let stats="ç»Ÿè®¡æ—¥å¿—:<br>";
    if(this.player){ stats+=`ç¡®è®¤å‡»æ€: ${this.player.kills||0}<br>ç”Ÿå­˜æ—¶é—´: ${Math.floor(this.player.lifeTime||0)}ç§’`; }
    else stats+="çŠ¶æ€: é˜µäº¡";
    document.getElementById('resultStats').innerHTML=stats;
    
    // AI Evolve
    AIGlobalMind.evolve(isWin ? false : true); // If player wins, AI lost
  }

  showMessage(msg){
    const div=document.createElement('div');
    div.innerText=msg;
    div.className='cmd-toast';
    div.style.top='20%';
    document.body.appendChild(div);
    setTimeout(()=>div.remove(), 2600);
  }
}

/* ===== å®ä½“ï¼šå¦å…‹ ===== */
class Tank{
  constructor(game,x,y,team,isPlayer){
    this.game=game;
    this.id=Math.random();
    this.type="TANK";
    this.x=x; this.y=y;
    this.prevX=x; this.prevY=y;
    this.team=team;
    this.isPlayer=isPlayer;
    this.angle = (isPlayer || team===CFG.teams.BLUE) ? 0 : Math.PI;
    this.targetAngle=this.angle;

    this.radius=14;
    this.maxHp=100; this.hp=100;
    this.dead=false; this.isWreckage=false;

    this.speed=CFG.tankSpeed;
    if(!isPlayer && team===CFG.teams.RED) this.speed*=EnemyStats.speedMult;

    this.shootTimer=0;
    this.skillCD={1:0,2:0};
    this.isDisabled=false; this.disabledTimer=0;

    this.kills=0;
    this.lifeTime=0;
    this.wasMoving=false;

    if(!isPlayer) this.ai=new AIController(this);
  }

  update(dt){
    if(this.isWreckage||this.dead) return;
    this.lifeTime += dt;

    this.prevX=this.x; this.prevY=this.y;

    if(this.isDisabled){
      this.disabledTimer-=dt;
      if(this.disabledTimer<=0) this.isDisabled=false;
      return;
    }

    if(this.shootTimer>0){
      let rate=1.0;
      if(!this.isPlayer && this.team===CFG.teams.RED) rate=EnemyStats.fireRateMult;
      this.shootTimer -= dt*rate;
    }
    if(this.skillCD[1]>0) this.skillCD[1]-=dt;
    if(this.skillCD[2]>0) this.skillCD[2]-=dt;

    let moveX=0, moveY=0, tryingShoot=false, mag=0;

    if(this.isPlayer){
      let rawX=0, rawY=0;
      if(this.game.keys['KeyW']) rawY=-1;
      if(this.game.keys['KeyS']) rawY=1;
      if(this.game.keys['KeyA']) rawX=-1;
      if(this.game.keys['KeyD']) rawX=1;
      if(this.game.keys['Space'] || this.game.keys['MouseLeft']) tryingShoot=true;

      if(this.game.touchInput.x!==0 || this.game.touchInput.y!==0){ rawX=this.game.touchInput.x; rawY=this.game.touchInput.y; }
      if(this.game.touchInput.shooting) tryingShoot=true;

      const camAng=-this.game.cameraAngle;
      moveX = rawX*Math.cos(camAng) - rawY*Math.sin(camAng);
      moveY = rawX*Math.sin(camAng) + rawY*Math.cos(camAng);
      mag = Math.hypot(moveX, moveY);
    }else if(this.ai){
      this.ai.update(dt);
      moveX=this.ai.moveDir.x; moveY=this.ai.moveDir.y;
      tryingShoot=this.ai.wantToShoot;
      mag=Math.hypot(moveX,moveY);
    }

    const moving = mag>0.1;
    if(this.isPlayer){
      if(moving) this.wasMoving=true;
      else if(this.wasMoving){ this.checkAutoAim(); this.wasMoving=false; }
    }

    if(moving){
      const inputAngle=Math.atan2(moveY,moveX);
      let diff=MathUtils.angleDiff(inputAngle,this.angle);
      let reversing=false;
      if(Math.abs(diff)>Math.PI*0.75){ reversing=true; this.targetAngle=inputAngle+Math.PI; }
      else this.targetAngle=inputAngle;

      diff=MathUtils.angleDiff(this.targetAngle,this.angle);
      const turn=CFG.tankTurnSpeed*(reversing?1.5:1.0);
      if(Math.abs(diff)>0.05) this.angle=MathUtils.lerpAngle(this.angle,this.targetAngle,turn*dt);

      let speedMod=1.0;
      if(Math.abs(diff)>0.5) speedMod=0.5;
      if(reversing) speedMod*=0.6;

      const finalSpeed=this.speed*speedMod*Math.min(1,mag);
      const dir=reversing?-1:1;
      const vx=Math.cos(this.angle)*finalSpeed*dir*dt;
      const vy=Math.sin(this.angle)*finalSpeed*dir*dt;
      this.moveAndCollide(vx,vy);
    }else if(this.ai && this.ai.target){
      const aim=this.ai.getAimAngle();
      this.targetAngle=aim;
      let diff=MathUtils.angleDiff(this.targetAngle,this.angle);
      if(Math.abs(diff)>0.02) this.angle+=Math.sign(diff)*CFG.tankTurnSpeed*dt*1.25;
    }

    if(tryingShoot) this.shoot();

    if(this.isPlayer){
      this.game.updateSkillUI('btnSkill1', this.skillCD[1], 10);
      this.game.updateSkillUI('btnSkill2', this.skillCD[2], 15);
      this.game.updateSkillUI('btnShoot', this.shootTimer, CFG.fireRate);
      document.getElementById('btnSkill1').classList.toggle('ready', this.skillCD[1]<=0);
      document.getElementById('btnSkill2').classList.toggle('ready', this.skillCD[2]<=0);
    }
  }

  checkAutoAim(){
    let best=null, min=Infinity;
    const scan=MathUtils.degToRad(AUTO_AIM_ANGLE);
    this.game.tanks.forEach(t=>{
      if(t.team!==this.team && !t.dead && !t.isWreckage){
        const d=MathUtils.dist(this.x,this.y,t.x,t.y);
        if(d<CFG.visionDist){
          const a=Math.atan2(t.y-this.y,t.x-this.x);
          const diff=Math.abs(MathUtils.angleDiff(a,this.angle));
          if(diff<scan && diff<min){ min=diff; best=t; }
        }
      }
    });
    if(best){
      const a=Math.atan2(best.y-this.y,best.x-this.x);
      this.angle=a; this.targetAngle=a;
    }
  }

  moveAndCollide(vx,vy){
    this.x+=vx; if(this.checkCollision()) this.x-=vx;
    this.y+=vy; if(this.checkCollision()) this.y-=vy;
    this.x=MathUtils.clamp(this.x,this.radius,CFG.mapWidth*CFG.tileSize-this.radius);
    this.y=MathUtils.clamp(this.y,this.radius,CFG.mapHeight*CFG.tileSize-this.radius);
  }

  checkCollision(){
    const pts=[
      {x:this.x,y:this.y},
      {x:this.x+this.radius*0.85,y:this.y},
      {x:this.x-this.radius*0.85,y:this.y},
      {x:this.x,y:this.y+this.radius*0.85},
      {x:this.x,y:this.y-this.radius*0.85}
    ];
    for(const p of pts){
      const tx=Math.floor(p.x/CFG.tileSize), ty=Math.floor(p.y/CFG.tileSize);
      if(this.game.map[ty] && this.game.map[ty][tx]>0) return true;
    }
    for(const o of this.game.tanks){
      if(o!==this){
        if(!o.dead || o.isWreckage){
          if(MathUtils.dist(this.x,this.y,o.x,o.y) < this.radius+o.radius) return true;
        }
      }
    }
    // Fix 1: Collision with Jet Wrecks
    for(const j of this.game.jets){
      if(j.isWreckage){
        if(MathUtils.dist(this.x,this.y,j.x,j.y) < this.radius + CFG.jetWreckRadius){ return true; }
      }
    }
    return false;
  }

  shoot(){
    if(this.shootTimer>0) return;

    if(this.ai && this.ai.target){
      const a=this.ai.getAimAngle();
      const diff=MathUtils.angleDiff(a,this.angle);
      if(Math.abs(diff)>0.28) return;
      this.game.markEngagement(this.team, 2.4);
    }

    this.shootTimer=CFG.fireRate;
    const mx=this.x+Math.cos(this.angle)*20;
    const my=this.y+Math.sin(this.angle)*20;
    this.game.bullets.push(new Bullet(this.game,mx,my,this.angle,this));
    AudioSys.sfxShoot();

    if(this.ai) this.ai.onFirePulse();
  }

  takeDamage(dmg, attacker){
    if(this.dead||this.isWreckage) return;
    if(attacker && !attacker.isPlayer && attacker.team===CFG.teams.RED) dmg*=EnemyStats.dmgMult;
    this.hp-=dmg;
    if(this.ai) this.ai.onTakeDamage(dmg, attacker);

    this.game.broadcastSupport(this.x,this.y,this.team,"HIT");

    if(this.hp<=0){
      this.die();
      if(attacker) {
        attacker.kills++;
        // Record Death for Mind
        AIGlobalMind.recordEvent(this.team, this.x, this.y, true);
      }
    }
  }

  die(){
    this.dead=true;
    this.isWreckage=true;
    this.hp=0;
    AudioSys.sfxExplode();
    for(let i=0;i<30;i++){
      this.game.particles.push(new Particle(this.x,this.y,'#e74c3c',0.8));
      this.game.particles.push(new Particle(this.x,this.y,'#f1c40f',0.5));
    }
    this.game.broadcastSupport(this.x,this.y,this.team,"ALLY_DOWN");
  }

  activateSkill(idx){
    if(this.skillCD[idx]>0 || this.isDisabled) return;
    if(idx===1){
      this.skillCD[1]=10;
      this.game.smokes.push(new Smoke(this.x,this.y));
      AudioSys.sfxSkill();
    }else if(idx===2){
      this.skillCD[2]=15;
      AudioSys.sfxEmp();
      this.game.tanks.forEach(t=>{
        if(t!==this && !t.dead && !t.isWreckage && t.team!==this.team && MathUtils.dist(this.x,this.y,t.x,t.y)<200){
          t.isDisabled=true; t.disabledTimer=CFG.empDuration;
          for(let i=0;i<10;i++) this.game.particles.push(new Particle(t.x,t.y,'#4af626'));
        }
      });
      for(let i=0;i<20;i++){
        const a=Math.random()*Math.PI*2, d=Math.random()*200;
        this.game.particles.push(new Particle(this.x+Math.cos(a)*d,this.y+Math.sin(a)*d,'#4af626',0.5));
      }
    }
  }

  drawShadow(ctx){
    if(this.dead||this.isWreckage) return;
    ctx.save();
    ctx.translate(this.x+4,this.y+4);
    ctx.rotate(this.angle);
    ctx.fillStyle='rgba(0,0,0,0.55)';
    ctx.fillRect(-18,-18,36,36);
    ctx.restore();
  }

  draw(ctx){
    if(this.isWreckage){
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
      ctx.drawImage(SpriteCache.tank.WRECK,-20,-20);
      ctx.restore();
      return;
    }
    if(this.dead) return;

    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    let sprite=null;
    if(this.isDisabled) sprite=SpriteCache.tank.DISABLED;
    else if(this.isPlayer) sprite=SpriteCache.tank.PLAYER;
    else sprite=(this.team===CFG.teams.BLUE)?SpriteCache.tank.BLUE:SpriteCache.tank.RED;
    ctx.drawImage(sprite,-20,-20);
    if(this.isDisabled && Math.random()>0.5){
      ctx.strokeStyle='#4af626'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.random()*30-15,Math.random()*30-15);
      ctx.stroke();
    }
    ctx.restore();

    if(this.hp<this.maxHp && !this.isWreckage){
      const w=30;
      ctx.fillStyle='#333'; ctx.fillRect(this.x-w/2,this.y-28,w,4);
      ctx.fillStyle=(this.team===CFG.teams.BLUE)?'#4af626':'#ff3333';
      ctx.fillRect(this.x-w/2,this.y-28,w*(this.hp/this.maxHp),4);
    }
  }
}

/* ===== å®ä½“ï¼šæˆ˜æ–—æœº ===== */
class Jet{
  constructor(game,x,y,team,isPlayer){
    this.game=game; this.id=Math.random();
    this.type="JET";
    this.x=x; this.y=y;
    this.prevX=x; this.prevY=y;
    this.team=team; this.isPlayer=isPlayer;
    this.angle=(team===CFG.teams.BLUE)?0:Math.PI;
    this.targetAngle=this.angle;
    this.radius=18;

    this.maxHp=CFG.jetHp;
    this.hp=this.maxHp;

    this.dead=false;
    this.isWreckage=false;

    this.speed=CFG.jetSpeed;
    this.shootTimer=0;

    this.skillCD={1:0,2:0};
    this.kills=0;
    this.lifeTime=0;

    this.crashing=false;
    this.crashTimer=0;
    this.lastVx=0; this.lastVy=0;
    this.forcedReturn=0;

    if(!isPlayer) this.ai=new JetAI(this);
  }

  update(dt){
    // Wreckage persists for rendering and collision, but doesn't update logic
    if(this.dead && this.isWreckage) return;
    this.lifeTime+=dt;

    this.prevX=this.x; this.prevY=this.y;

    if(this.skillCD[1]>0) this.skillCD[1]-=dt;
    if(this.skillCD[2]>0) this.skillCD[2]-=dt;

    if(this.crashing){
      this.crashTimer-=dt;
      this.x += this.lastVx*dt*0.85;
      this.y += this.lastVy*dt*0.85;
      if(Math.random()<0.6) this.game.particles.push(new Particle(this.x,this.y,'#666',0.55));
      if(this.crashTimer<=0){
        this.explodeCrash();
        this.dead=true;
        this.isWreckage=true;
      }
      return;
    }

    let turnInput=0, tryingShoot=false;

    if(this.isPlayer){
      if(this.game.keys['KeyA']) turnInput=-1;
      if(this.game.keys['KeyD']) turnInput=1;
      if(this.game.keys['Space'] || this.game.keys['MouseLeft']) tryingShoot=true;
      if(this.game.touchInput.shooting) tryingShoot=true;

      if(this.game.touchInput.x!==0 || this.game.touchInput.y!==0){
        const camAng=-this.game.cameraAngle;
        const rawX=this.game.touchInput.x, rawY=this.game.touchInput.y;
        const mx=rawX*Math.cos(camAng)-rawY*Math.sin(camAng);
        const my=rawX*Math.sin(camAng)+rawY*Math.cos(camAng);
        const desired=Math.atan2(my,mx);
        const diff=MathUtils.angleDiff(desired,this.angle);
        turnInput=MathUtils.clamp(diff*1.2,-1,1);
      }
    }else if(this.ai){
      this.ai.update(dt);
      turnInput=this.ai.turn;
      tryingShoot=this.ai.wantShoot;
    }

    const minX=10,minY=10;
    const maxX=CFG.mapWidth*CFG.tileSize-10;
    const maxY=CFG.mapHeight*CFG.tileSize-10;
    const out=(this.x<minX||this.x>maxX||this.y<minY||this.y>maxY);
    if(out && this.forcedReturn<=0){
      this.forcedReturn=1.2;
      this.targetAngle=Math.atan2((CFG.mapHeight*CFG.tileSize/2)-this.y,(CFG.mapWidth*CFG.tileSize/2)-this.x);
      if(this.isPlayer) this.game.showMessage("è¾¹ç•Œè­¦å‘Šï¼šå¼ºåˆ¶è¿”èˆª");
    }

    if(this.forcedReturn>0){
      this.forcedReturn-=dt;
      const diff=MathUtils.angleDiff(this.targetAngle,this.angle);
      this.angle += Math.sign(diff)*CFG.jetTurnSpeed*dt*1.6;
      tryingShoot=false;
    }else{
      this.angle += turnInput*CFG.jetTurnSpeed*dt;
    }

    const vx=Math.cos(this.angle)*this.speed;
    const vy=Math.sin(this.angle)*this.speed;
    this.lastVx=vx; this.lastVy=vy;
    this.x += vx*dt; this.y += vy*dt;

    this.x=MathUtils.clamp(this.x,-200,CFG.mapWidth*CFG.tileSize+200);
    this.y=MathUtils.clamp(this.y,-200,CFG.mapHeight*CFG.tileSize+200);

    if(this.shootTimer>0) this.shootTimer-=dt;
    if(tryingShoot) this.shoot();

    if(this.isPlayer){
      this.game.updateSkillUI('btnSkill1', this.skillCD[1], 10);
      this.game.updateSkillUI('btnSkill2', this.skillCD[2], 15);
      this.game.updateSkillUI('btnShoot', this.shootTimer, CFG.jetGunRate);
      document.getElementById('btnSkill1').classList.toggle('ready', this.skillCD[1]<=0);
      document.getElementById('btnSkill2').classList.toggle('ready', this.skillCD[2]<=0);
    }
  }

  shoot(){
    if(this.shootTimer>0) return;
    this.shootTimer=CFG.jetGunRate;
    const mx=this.x+Math.cos(this.angle)*30;
    const my=this.y+Math.sin(this.angle)*30;
    this.game.airBullets.push(new AirBullet(this.game,mx,my,this.angle,this));
    AudioSys.sfxJetGun();
    if(this.ai) this.ai.onFirePulse();
  }

  activateSkill(idx){
    if(this.skillCD[idx]>0) return;
    if(idx===1){
      this.skillCD[1]=10;
      const target=this.findBestAirTarget();
      this.game.missiles.push(new HomingMissile(this.game,this.x,this.y,this.angle,this,target));
      AudioSys.sfxMissile();
    }else if(idx===2){
      this.skillCD[2]=15;
      const tx=this.x+Math.cos(this.angle)*80;
      const ty=this.y+Math.sin(this.angle)*80;
      this.dropBomb(tx,ty,true);
      AudioSys.sfxBomb();
    }
  }

  dropBomb(x,y,fromPlayer=false){
    if(this.team===CFG.teams.BLUE){
      this.game.showMessage(`âš  æŠ•å¼¹ï¼šæ ‡å®šåæ ‡ (${Math.floor(x)}, ${Math.floor(y)})`);
    }
    this.game.addDangerZone(x,y,CFG.bombRadius,this.team,CFG.bombFallTime+0.45);
    this.game.bombs.push(new Bomb(this.game,x,y,this.team,fromPlayer?this:null));
  }

  findBestAirTarget(){
    const enemies=this.game.jets.filter(j=>j.team!==this.team && !j.dead && !j.isWreckage && !j.crashing);
    if(!enemies.length) return null;
    let best=null, bestD=Infinity;
    for(const e of enemies){
      const d=MathUtils.dist(this.x,this.y,e.x,e.y);
      if(d<bestD && d<CFG.jetVision){ bestD=d; best=e; }
    }
    return best;
  }

  takeDamage(dmg, attacker){
    if(this.dead || this.crashing) return;
    this.hp-=dmg;
    this.game.broadcastSupport(this.x,this.y,this.team,"HIT");
    if(this.hp<=0){
      this.startCrash();
      if(attacker) {
        attacker.kills++;
        AIGlobalMind.recordEvent(this.team, this.x, this.y, true);
      }
    }
  }

  startCrash(){
    this.crashing=true;
    this.hp=0;
    this.crashTimer=1.2;
    AudioSys.sfxExplode();
    for(let i=0;i<10;i++) this.game.particles.push(new Particle(this.x,this.y,'#f1c40f',0.55));
    this.game.broadcastSupport(this.x,this.y,this.team,"ALLY_DOWN");
  }

  explodeCrash(){
    const x=this.x, y=this.y;
    this.game.destroyTiles3x3(x,y);
    for(let i=0;i<36;i++){
      this.game.particles.push(new Particle(x,y,'#e74c3c',0.9));
      if(i%2===0) this.game.particles.push(new Particle(x,y,'#f1c40f',0.7));
    }
    this.game.tanks.forEach(t=>{
      if(t.dead||t.isWreckage) return;
      const d=MathUtils.dist(x,y,t.x,t.y);
      if(d<CFG.crashRadius){
        let dmg=CFG.crashDamage*(1-d/CFG.crashRadius);
        if(t.team===this.team) dmg*=0.5;
        t.takeDamage(dmg,null);
      }
    });
  }

  draw(ctx){
    if(this.dead && this.isWreckage){
      ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
      // Fix 4: Better wreck art
      ctx.drawImage(SpriteCache.jet.WRECK,-32,-32);
      ctx.restore();
      return;
    }
    if(this.dead) return;

    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    let sprite=this.isPlayer?SpriteCache.jet.PLAYER:((this.team===CFG.teams.BLUE)?SpriteCache.jet.BLUE:SpriteCache.jet.RED);
    ctx.drawImage(sprite,-32,-32);

    if(Math.random()<0.6){
      ctx.fillStyle='rgba(255,176,0,0.22)'; ctx.fillRect(-18,-2,7,1);
      ctx.fillStyle='rgba(255,51,51,0.15)'; ctx.fillRect(-18,1,6,1);
    }
    ctx.restore();

    if(!this.crashing && !this.isWreckage && this.hp>0 && this.hp<this.maxHp){
      const w=34;
      ctx.fillStyle='#333'; ctx.fillRect(this.x-w/2,this.y-36,w,4);
      ctx.fillStyle=(this.team===CFG.teams.BLUE)?'#4af626':'#ff3333';
      ctx.fillRect(this.x-w/2,this.y-36,w*(this.hp/this.maxHp),4);
    }
  }
}

/* ===== æˆ˜æ–—æœºAI ===== */
class JetAI{
  constructor(jet){
    this.jet=jet;
    this.turn=0;
    this.wantShoot=false;

    this.task=null;

    this.role="SQUAD"; // SQUAD / SCOUT
    this.leaderId=null;
    this.slotIndex=0;
    this.turnVel=0;

    this.searchPhase=null;
    this.trackTarget=null;
    this.trackPoint=null;
    this.searchAngle=MathUtils.rand(-Math.PI,Math.PI);
    this.searchTimer=0;

    this.firePulseCD=0;
    this.contactCD=0;
  }

  setTask(x,y,kind="MARK",ttl=4.0){
    this.task={x,y,kind,ttl};
  }

  setOverwatch(x,y){
    this.setTask(x,y,"OVERWATCH",2.2);
  }

  beginSearch(){
    this.role="SCOUT";
    this.searchPhase="SEARCH";
    this.trackTarget=null;
    this.trackPoint=null;
    this.searchTimer=0;
  }
  beginTrack(target){
    this.role="SCOUT";
    this.searchPhase="TRACK";
    this.trackTarget=target || null;
    this.trackPoint=target?{x:target.x,y:target.y}:null;
  }
  updateTrackPoint(x,y,target){
    this.searchPhase="TRACK";
    this.trackPoint={x,y};
    this.trackTarget=target||this.trackTarget;
  }
  beginReturn(){
    this.role="SCOUT";
    this.searchPhase="RETURN";
    this.trackTarget=null;
    this.trackPoint=null;
  }
  endSearch(){
    this.role="SQUAD";
    this.searchPhase=null;
    this.trackTarget=null;
    this.trackPoint=null;
  }

  onSupportSignal(x,y,kind){
    if(this.role==="SCOUT") return;
    if(this.task && this.task.kind==="MARK") return;
    this.setTask(x,y,"SUPPORT",3.0);
  }

  onFirePulse(){
    if(this.firePulseCD<=0){
      this.jet.game.broadcastSupport(this.jet.x,this.jet.y,this.jet.team,"FIRE");
      this.firePulseCD=1.5;
    }
  }

  update(dt){
    this.wantShoot=false;
    this.firePulseCD=Math.max(0,this.firePulseCD-dt);
    this.contactCD=Math.max(0,this.contactCD-dt);

    const g=this.jet.game;

    if(this.role==="SCOUT"){
      if(this.searchPhase==="SEARCH"){
        this.searchTimer += dt;
        const enemyBase={x:CFG.mapWidth*CFG.tileSize-250,y:CFG.mapHeight*CFG.tileSize-250};
        if(this.searchTimer>1.2){
          this.searchTimer=0;
          const toward=Math.atan2(enemyBase.y-this.jet.y, enemyBase.x-this.jet.x);
          this.searchAngle = MathUtils.lerpAngle(this.searchAngle, toward + MathUtils.rand(-0.55,0.55), 0.45);
        }
        const diff=MathUtils.angleDiff(this.searchAngle,this.jet.angle);
        this.turnVel = MathUtils.clamp(this.turnVel + diff*0.38*dt, -1.0, 1.0);
        this.turnVel *= Math.pow(0.002, dt);
        this.turn = MathUtils.clamp(this.turnVel, -0.85, 0.85);
        return;
      }
      if(this.searchPhase==="TRACK"){
        const p=this.trackPoint;
        if(p){
          const orbitR=240;
          const orbitAng = (Date.now()*0.0015) % (Math.PI*2);
          const ox = p.x + Math.cos(orbitAng)*orbitR;
          const oy = p.y + Math.sin(orbitAng)*orbitR;
          const desired=Math.atan2(oy-this.jet.y, ox-this.jet.x);
          const diff=MathUtils.angleDiff(desired,this.jet.angle);
          this.turnVel = MathUtils.clamp(this.turnVel + diff*0.55*dt, -1.2, 1.2);
          this.turnVel *= Math.pow(0.001, dt);
          this.turn = MathUtils.clamp(this.turnVel, -1, 1);

          const enemyJets = g.jets.filter(j=>j.team!==this.jet.team && !j.dead && !j.isWreckage && !j.crashing);
          let airTarget=null, bestD=Infinity;
          for(const e of enemyJets){
            const d=MathUtils.dist(this.jet.x,this.jet.y,e.x,e.y);
            if(d<bestD && d<CFG.jetVision){ bestD=d; airTarget=e; }
          }
          if(airTarget){
            const ad=Math.abs(MathUtils.angleDiff(Math.atan2(airTarget.y-this.jet.y,airTarget.x-this.jet.x), this.jet.angle));
            if(ad<0.30) this.wantShoot=true;
            if(this.jet.skillCD[1]<=0 && Math.random()<0.08){
              this.jet.skillCD[1]=10;
              g.missiles.push(new HomingMissile(g,this.jet.x,this.jet.y,this.jet.angle,this.jet,airTarget));
              AudioSys.sfxMissile();
            }
            if(this.contactCD<=0){
              g.broadcastSupport(this.jet.x,this.jet.y,this.jet.team,"CONTACT");
              this.contactCD=2.0;
            }
          }
        }
        return;
      }
      if(this.searchPhase==="RETURN"){
        const cen=g.getJetSquadCenter(this.jet.team);
        const desired=Math.atan2(cen.y-this.jet.y, cen.x-this.jet.x);
        const diff=MathUtils.angleDiff(desired,this.jet.angle);
        this.turnVel = MathUtils.clamp(this.turnVel + diff*0.45*dt, -1.0, 1.0);
        this.turnVel *= Math.pow(0.002, dt);
        this.turn = MathUtils.clamp(this.turnVel, -0.85, 0.85);
        return;
      }
    }

    const enemyJets = g.jets.filter(j=>j.team!==this.jet.team && !j.dead && !j.isWreckage && !j.crashing);
    const enemyTanks = g.tanks.filter(t=>t.team!==this.jet.team && !t.dead && !t.isWreckage);

    if(this.task){
      this.task.ttl -= dt;
      const dx=this.task.x-this.jet.x, dy=this.task.y-this.jet.y;
      const desired=Math.atan2(dy,dx);
      const diff=MathUtils.angleDiff(desired,this.jet.angle);

      this.turnVel = MathUtils.clamp(this.turnVel + diff*0.55*dt, -1.2, 1.2);
      this.turnVel *= Math.pow(0.001, dt);
      this.turn = MathUtils.clamp(this.turnVel, -1, 1);

      const d=Math.hypot(dx,dy);

      if(d<240){
        let nearEnemyJet=null, nearD=Infinity;
        for(const e of enemyJets){
          const dd=MathUtils.dist(this.jet.x,this.jet.y,e.x,e.y);
          if(dd<nearD && dd<520){ nearD=dd; nearEnemyJet=e; }
        }
        if(nearEnemyJet){
          const ad=Math.abs(MathUtils.angleDiff(Math.atan2(nearEnemyJet.y-this.jet.y,nearEnemyJet.x-this.jet.x), this.jet.angle));
          if(ad<0.30) this.wantShoot=true;
          if(this.jet.skillCD[1]<=0 && Math.random()<0.12){
            this.jet.skillCD[1]=10;
            g.missiles.push(new HomingMissile(g,this.jet.x,this.jet.y,this.jet.angle,this.jet,nearEnemyJet));
            AudioSys.sfxMissile();
          }
          if(this.contactCD<=0){
            g.broadcastSupport(this.jet.x,this.jet.y,this.jet.team,"CONTACT");
            this.contactCD=2.0;
          }
        }else{
          if(enemyTanks.length>0 && this.jet.skillCD[2]<=0 && Math.random()<0.08){
            const bx=this.task.x, by=this.task.y;
            const hasGround = enemyTanks.some(t=>MathUtils.dist(t.x,t.y,bx,by) < CFG.bombRadius*0.95);
            if(hasGround){
              const friendlyClose = g.tanks.some(t=>t.team===this.jet.team && !t.dead && !t.isWreckage && MathUtils.dist(t.x,t.y,bx,by)<CFG.bombRadius*0.82);
              if(!friendlyClose){
                this.jet.skillCD[2]=15;
                this.jet.dropBomb(bx,by,false);
                AudioSys.sfxBomb();
                g.markEngagement(this.jet.team, 2.8);
              }
            }
          }
        }
      }

      if(this.task.ttl<=0) this.task=null;
      return;
    }

    let airTarget=null, bestD=Infinity;
    for(const e of enemyJets){
      const d=MathUtils.dist(this.jet.x,this.jet.y,e.x,e.y);
      if(d<bestD && d<CFG.jetVision){ bestD=d; airTarget=e; }
    }
    if(airTarget){
      const dx=airTarget.x-this.jet.x, dy=airTarget.y-this.jet.y;
      const desired=Math.atan2(dy,dx);
      const diff=MathUtils.angleDiff(desired,this.jet.angle);

      this.turnVel = MathUtils.clamp(this.turnVel + diff*0.55*dt, -1.2, 1.2);
      this.turnVel *= Math.pow(0.001, dt);
      this.turn = MathUtils.clamp(this.turnVel, -1, 1);

      if(Math.abs(diff)<0.25) this.wantShoot=true;

      if(this.jet.skillCD[1]<=0 && Math.random()<0.03){
        this.jet.skillCD[1]=10;
        g.missiles.push(new HomingMissile(g,this.jet.x,this.jet.y,this.jet.angle,this.jet,airTarget));
        AudioSys.sfxMissile();
      }

      if(this.contactCD<=0){
        g.broadcastSupport(this.jet.x,this.jet.y,this.jet.team,"CONTACT");
        this.contactCD=2.0;
      }
      return;
    }

    if(enemyTanks.length>0 && this.jet.skillCD[2]<=0 && Math.random()<0.025){
      const bestCluster = pickTankCluster(enemyTanks, this.jet.x, this.jet.y);
      if(bestCluster){
        const bx=bestCluster.x, by=bestCluster.y;
        const friendlyClose = g.tanks.some(t=>t.team===this.jet.team && !t.dead && !t.isWreckage && MathUtils.dist(t.x,t.y,bx,by)<CFG.bombRadius*0.82);
        if(!friendlyClose){
          this.setTask(bx,by,"SUPPORT",3.6);
          return;
        }
      }
    }

    const cen=g.getJetSquadCenter(this.jet.team);
    const squad=g.jets.filter(j=>j.team===this.jet.team && !j.dead && !j.isWreckage && !j.crashing);
    const leader=squad[0] || this.jet;
    this.leaderId=leader.id;
    let idx=0;
    for(let i=0;i<squad.length;i++){ if(squad[i].id===this.jet.id){ idx=i; break; } }
    this.slotIndex=idx;

    const row=Math.floor(idx/3), col=idx%3;
    const offR=120 + row*70;
    const offA = leader.angle + (col===0?0:col===1?0.55:-0.55) + row*0.18;
    const fx = leader.x - Math.cos(offA)*offR;
    const fy = leader.y - Math.sin(offA)*offR;

    const enemyBase={x:CFG.mapWidth*CFG.tileSize-250,y:CFG.mapHeight*CFG.tileSize-250};
    const pushAng=Math.atan2(enemyBase.y-cen.y, enemyBase.x-cen.x);
    const goalX = MathUtils.lerp(fx, cen.x + Math.cos(pushAng)*240, 0.35);
    const goalY = MathUtils.lerp(fy, cen.y + Math.sin(pushAng)*240, 0.35);

    const desired=Math.atan2(goalY-this.jet.y, goalX-this.jet.x);
    const diff=MathUtils.angleDiff(desired,this.jet.angle);
    this.turnVel = MathUtils.clamp(this.turnVel + diff*0.35*dt, -0.9, 0.9);
    this.turnVel *= Math.pow(0.003, dt);
    this.turn=MathUtils.clamp(this.turnVel,-0.65,0.65);

    function pickTankCluster(tanks, x, y){
      let best=null, bestScore=0;
      for(const t of tanks){
        const d=MathUtils.dist(x,y,t.x,t.y);
        if(d>CFG.jetVision) continue;
        let count=0;
        for(const o of tanks){
          if(MathUtils.dist(t.x,t.y,o.x,o.y)<180) count++;
        }
        if(count>bestScore){
          bestScore=count;
          best={x:t.x,y:t.y};
        }
      }
      return (bestScore>=2)?best:null;
    }
  }
}

/* ===== å¦å…‹AIï¼ˆè¿›åŒ–ç‰ˆï¼‰ ===== */
class AIController{
  constructor(tank){
    this.tank=tank;
    this.state='IDLE';
    this.target=null;
    this.moveDir={x:0,y:0};
    this.wantToShoot=false;

    this.path=[]; this.thinkTimer=Math.random()*0.5; this.updateInterval=0.2;
    this.stuckTimer=0; this.lastPos={x:tank.x,y:tank.y};

    // Load genes from shared mind + variations
    this.genes = { 
        aggression: AIGlobalMind.data.genes.aggression + MathUtils.rand(-0.1, 0.1),
        caution: AIGlobalMind.data.genes.caution + MathUtils.rand(-0.1, 0.1),
        teamwork: AIGlobalMind.data.genes.teamwork + MathUtils.rand(-0.1, 0.1)
    };
    
    this.fear=0;
    this.commandState=null; this.commander=null;
    this.investigatePos=null;

    this.firePulseCD=0;
    this.helpPulseCD=0;

    this.offsetAngle = MathUtils.rand(-Math.PI, Math.PI);

    this.targetLockTimer=0;
    this.goalHoldTimer=0;
    this.lastGoal=null;

    this.aiVisionMult = 1.25;
    this.smoothDir={x:0,y:0};
    this.searchTarget=null;
  }

  receiveCommand(cmd, commander){
    this.commandState=cmd;
    this.commander=commander;
    this.state='COMMAND_EXEC';
    this.investigatePos=null;
    this.path=[];
    this.stuckTimer=0;
    this.thinkTimer=0;
    this.goalHoldTimer=0;
  }

  receiveSearchTarget(x,y, commander){
    this.searchTarget={x,y,ttl:8.0};
    this.receiveCommand("SEARCH", commander);
  }

  onSupportSignal(x,y,kind){
    const g=this.tank.game;
    const engaged = g.isTeamEngaged(this.tank.team);

    const scatterMode = (g.activeCommand==="SCATTER") || (this.commandState==="SCATTER");
    const allow =
      (engaged && kind==="HIT") ||
      (kind==="ALLY_DOWN" && engaged && this.genes.teamwork>0.45) ||
      (kind==="RECON" && engaged && scatterMode && this.genes.teamwork>0.55);

    if(!allow) return;

    const pri = (kind==="ALLY_DOWN")?3 : (kind==="HIT")?2 : 1;
    if(this.state==="CHASE" && this.target && !this.target.dead && this.targetLockTimer>0.6 && pri<3) return;

    this.state='INVESTIGATE';
    this.investigatePos={x,y,pri,stamp:Date.now()};
    this.path=[];
    this.thinkTimer=0;
    this.goalHoldTimer=0;
  }

  onFirePulse(){
    if(this.firePulseCD<=0){
      if(this.target && !this.target.dead && !this.target.isWreckage){
        this.tank.game.broadcastSupport(this.tank.x,this.tank.y,this.tank.team,"FIRE");
        this.tank.game.markEngagement(this.tank.team, 2.2);
      }
      this.firePulseCD=2.0;
    }
  }

  onTakeDamage(dmg, attacker){
    this.fear += dmg*this.genes.caution;
    if(this.fear>50 && this.state!=='COMMAND_EXEC') this.state='FLEE';
    if(attacker && !attacker.dead && !attacker.isWreckage){
      this.target=attacker;
      this.targetLockTimer=1.8;
      this.investigatePos=null;
      this.thinkTimer=0;
      this.goalHoldTimer=0;
    }
  }

  investigate(x,y){
    if(this.state!=='CHASE' && this.state!=='FLEE' && this.state!=='COMMAND_EXEC'){
      this.state='INVESTIGATE';
      this.investigatePos={x,y,pri:1,stamp:Date.now()};
      this.path=[];
      this.thinkTimer=0;
      this.goalHoldTimer=0;
    }
  }

  evaluateTactics(visibleEnemies){
    if(this.tank.skillCD[2]<=0 && (this.commandState==='SQUAD_EMP' || this.genes.aggression>0.7)){
      let close=0;
      this.tank.game.tanks.forEach(t=>{
        if(t.team!==this.tank.team && !t.dead && !t.isWreckage){
          if(MathUtils.dist(this.tank.x,this.tank.y,t.x,t.y)<180) close++;
        }
      });
      if(close>0){
        this.tank.activateSkill(2);
        if(this.commandState==='SQUAD_EMP') this.commandState=null;
      }
    }
    if(this.tank.skillCD[1]<=0 && (this.commandState==='SQUAD_SMOKE' || this.state==='FLEE')){
      if(visibleEnemies.length>0 || this.state==='FLEE'){
        this.tank.activateSkill(1);
        if(this.commandState==='SQUAD_SMOKE') this.commandState=null;
      }
    }
  }

  update(dt){
    this.fear=Math.max(0,this.fear-dt*5);
    this.wantToShoot=false;
    this.firePulseCD=Math.max(0,this.firePulseCD-dt);
    this.helpPulseCD=Math.max(0,this.helpPulseCD-dt);
    this.targetLockTimer=Math.max(0,this.targetLockTimer-dt);
    this.goalHoldTimer=Math.max(0,this.goalHoldTimer-dt);

    if(this.searchTarget){
      this.searchTarget.ttl-=dt;
      if(this.searchTarget.ttl<=0) this.searchTarget=null;
    }

    let avoidX=0, avoidY=0;
    for(const dz of this.tank.game.dangerZones){
      if(dz.team!==this.tank.team) continue;
      const d=MathUtils.dist(this.tank.x,this.tank.y,dz.x,dz.y);
      if(d < dz.r*1.05){
        const push=(dz.r*1.05 - d) / (dz.r*1.05);
        const dx=(this.tank.x - dz.x) / (d||1);
        const dy=(this.tank.y - dz.y) / (d||1);
        avoidX += dx * push * 1.8;
        avoidY += dy * push * 1.8;
      }
    }

    let sepX=0, sepY=0;
    this.tank.game.tanks.forEach(other=>{
      if(other!==this.tank && !other.dead && !other.isWreckage){
        const d=MathUtils.dist(this.tank.x,this.tank.y,other.x,other.y);
        if(d<42){
          const push=42-d;
          sepX += (this.tank.x-other.x)/(d||1)*push;
          sepY += (this.tank.y-other.y)/(d||1)*push;
        }
      }
    });

    let wallX=0, wallY=0;
    const aheadAng=this.tank.angle;
    const ax=this.tank.x+Math.cos(aheadAng)*28;
    const ay=this.tank.y+Math.sin(aheadAng)*28;
    const tx=Math.floor(ax/CFG.tileSize), ty=Math.floor(ay/CFG.tileSize);
    if(this.tank.game.map[ty] && this.tank.game.map[ty][tx]>0){
      const side = (Math.sin(aheadAng) >= 0)?1:-1;
      wallX += -Math.sin(aheadAng)*0.9*side;
      wallY +=  Math.cos(aheadAng)*0.9*side;
    }

    // AI Mind Influence (Tactical Map)
    // Scan ahead, if the tactical score is low (high death risk), steer away
    // If high kill opportunity, steer towards
    const lookAheadDist = 60;
    const lx = this.tank.x + Math.cos(aheadAng)*lookAheadDist;
    const ly = this.tank.y + Math.sin(aheadAng)*lookAheadDist;
    const tacticalScore = AIGlobalMind.getTacticalScore(lx, ly);
    let tactX=0, tactY=0;
    
    if(tacticalScore < 0.4 && this.state !== 'FLEE'){
        // Dangerous area ahead!
        tactX = -Math.cos(aheadAng)*0.5;
        tactY = -Math.sin(aheadAng)*0.5;
    } else if(tacticalScore > 0.6 && this.state === 'PATROL'){
        // Good area, encourage movement
        tactX = Math.cos(aheadAng)*0.2;
        tactY = Math.sin(aheadAng)*0.2;
    }

    this.thinkTimer -= dt;
    if(this.thinkTimer<=0){
      this.thinkTimer=this.updateInterval + Math.random()*0.1;
      this.think(dt);
    }

    this.followPath();

    let dirX = this.moveDir.x + sepX*0.045 + avoidX*0.12 + wallX*0.25 + tactX*0.3;
    let dirY = this.moveDir.y + sepY*0.045 + avoidY*0.12 + wallY*0.25 + tactY*0.3;

    this.smoothDir.x = MathUtils.lerp(this.smoothDir.x, dirX, 0.22);
    this.smoothDir.y = MathUtils.lerp(this.smoothDir.y, dirY, 0.22);

    const m=Math.hypot(this.smoothDir.x,this.smoothDir.y);
    if(m>1){ this.smoothDir.x/=m; this.smoothDir.y/=m; }

    this.moveDir.x=this.smoothDir.x;
    this.moveDir.y=this.smoothDir.y;

    if(MathUtils.dist(this.tank.x,this.tank.y,this.lastPos.x,this.lastPos.y)<2) this.stuckTimer+=dt;
    else{ this.stuckTimer=0; this.lastPos={x:this.tank.x,y:this.tank.y}; }

    if(this.stuckTimer>0.55){
      const ang = Math.atan2(this.moveDir.y,this.moveDir.x) + (Math.random()<0.5?1:-1)*Math.PI/2;
      this.moveDir.x = Math.cos(ang);
      this.moveDir.y = Math.sin(ang);
      if(this.stuckTimer>1.1){
        const a=Math.random()*Math.PI*2;
        this.moveDir.x=Math.cos(a); this.moveDir.y=Math.sin(a);
        this.path=[];
      }
    }
  }

  think(dt){
    const enemies=this.tank.game.tanks.filter(t=>t.team!==this.tank.team && !t.dead && !t.isWreckage);
    const visible=enemies.filter(e=>this.canSee(e));
    this.evaluateTactics(visible);

    if(this.state==='FLEE' && this.fear<20) this.state='IDLE';

    if(this.state==='COMMAND_EXEC'){
      this.executeCommandLogic(dt, visible);
      return;
    }

    if(visible.length>0){
      let best=null, score=-1e9;
      for(const e of visible){
        const d=MathUtils.dist(this.tank.x,this.tank.y,e.x,e.y);
        const hpN = (100 - e.hp);
        const keep = (this.target===e)?220:0;
        const s = (600-d) + hpN*0.6 + keep;
        if(s>score){ score=s; best=e; }
      }
      if(this.state!=='FLEE'){
        if(!this.target || this.target.dead || this.target.isWreckage || this.targetLockTimer<=0){
          this.target=best;
          this.targetLockTimer=1.6;
        }
        this.state='CHASE';
        this.investigatePos=null;
      }
    }else if(this.state==='CHASE'){
      if(this.target && !this.target.dead){
        this.investigatePos={x:this.target.x,y:this.target.y,pri:1,stamp:Date.now()};
        this.state='INVESTIGATE';
      }else this.state='PATROL';
    }

    switch(this.state){
      case 'IDLE':
      case 'PATROL': this.patrol(dt); break;
      case 'CHASE': this.chase(dt); break;
      case 'FLEE': this.flee(dt,enemies); break;
      case 'INVESTIGATE': this.doInvestigate(dt); break;
    }
  }

  canSee(enemy){
    const d=MathUtils.dist(this.tank.x,this.tank.y,enemy.x,enemy.y);
    const maxD = this.tank.isPlayer ? CFG.visionDist : CFG.visionDist*this.aiVisionMult;
    if(d>maxD) return false;
    if(this.tank.game.isPosInSmoke(enemy.x,enemy.y)) return false;
    return this.tank.game.checkLineOfSight(this.tank.x,this.tank.y,enemy.x,enemy.y);
  }

  followPath(){
    if(this.path.length>0){
      let next=this.path[0];
      let d=MathUtils.dist(this.tank.x,this.tank.y,next.x,next.y);

      if(this.path.length>1){
        const nn=this.path[1];
        if(this.tank.game.checkLineOfSight(this.tank.x,this.tank.y,nn.x,nn.y)){
          this.path.shift();
          next=this.path[0];
          d=MathUtils.dist(this.tank.x,this.tank.y,next.x,next.y);
        }
      }

      if(d<24){
        this.path.shift();
        if(this.path.length===0){
          this.moveDir.x=0; this.moveDir.y=0;
          return;
        }
        next=this.path[0];
      }

      const dx=next.x-this.tank.x, dy=next.y-this.tank.y;
      const m=Math.hypot(dx,dy)||1;
      this.moveDir.x=dx/m;
      this.moveDir.y=dy/m;
    }
  }

  setGoal(x,y,hold=1.0){
    const g=this.tank.game;
    if(this.goalHoldTimer>0 && this.lastGoal){
      const dd=MathUtils.dist(this.lastGoal.x,this.lastGoal.y,x,y);
      if(dd<60) return;
    }
    this.goalHoldTimer=hold;
    this.lastGoal={x,y};

    if(g.checkLineOfSight(this.tank.x,this.tank.y,x,y)){
      this.path=[{x,y}];
    }else{
      const p=Pathfinder.findPath(this.tank.x,this.tank.y,x,y,g.map);
      this.path=p && p.length? p : [{x,y}];
    }
  }

  getAimAngle(){
    if(!this.target) return this.tank.angle;
    const t=this.target;
    const vx=(t.x-(t.prevX||t.x))/Math.max(0.016, this.updateInterval);
    const vy=(t.y-(t.prevY||t.y))/Math.max(0.016, this.updateInterval);
    const dist=MathUtils.dist(this.tank.x,this.tank.y,t.x,t.y);
    const time=dist/CFG.bulletSpeed;
    const px=t.x + vx*time*0.55;
    const py=t.y + vy*time*0.55;
    return Math.atan2(py-this.tank.y, px-this.tank.x);
  }

  planFlank(target){
    const g=this.tank.game;
    const baseAng=Math.atan2(target.y-this.tank.y, target.x-this.tank.x);
    let best=null, bestScore=-1e9;

    const radii=[180,220,260];
    const angles=[-1.1,-0.7,-0.45,0.45,0.7,1.1];

    for(const r of radii){
      for(const a of angles){
        const ang=baseAng+a;
        const x=target.x + Math.cos(ang)*r;
        const y=target.y + Math.sin(ang)*r;
        const tx=Math.floor(x/CFG.tileSize), ty=Math.floor(y/CFG.tileSize);
        if(tx<=1||ty<=1||tx>=CFG.mapWidth-1||ty>=CFG.mapHeight-1) continue;
        if(g.map[ty][tx]>0) continue;
        const losToTarget = g.checkLineOfSight(x,y,target.x,target.y) && !g.isPosInSmoke(target.x,target.y);
        if(!losToTarget) continue;

        const dSelf=MathUtils.dist(this.tank.x,this.tank.y,x,y);
        const dToTarget=MathUtils.dist(x,y,target.x,target.y);
        const score = (600-dSelf) + (260-Math.abs(220-dToTarget))*0.25;
        if(score>bestScore){
          bestScore=score;
          best={x,y};
        }
      }
    }
    return best;
  }

  patrol(dt){
    const g=this.tank.game;

    if(this.searchTarget){
      this.setGoal(this.searchTarget.x, this.searchTarget.y, 0.8);
      return;
    }
    if(g.searchRallyPoint && (g.activeCommand==="SEARCH" || this.commandState==="SEARCH") && g.isTeamEngaged(this.tank.team)){
      this.setGoal(g.searchRallyPoint.x, g.searchRallyPoint.y, 0.9);
      return;
    }

    if(g.customRallyPoint && g.activeCommand==='RALLY_POINT'){
      this.setGoal(g.customRallyPoint.x, g.customRallyPoint.y, 0.9);
      return;
    }

    if(g.activeCommand==='RALLY' || this.commandState==='RALLY'){
      const commander=this.commander || g.tanks.find(t=>t.team===this.tank.team && !t.dead && t.isPlayer) || null;
      const cx=commander?commander.x: (this.tank.team===CFG.teams.BLUE?250:(CFG.mapWidth*CFG.tileSize-250));
      const cy=commander?commander.y: (this.tank.team===CFG.teams.BLUE?250:(CFG.mapHeight*CFG.tileSize-250));
      const ang=Math.atan2(this.tank.y-cy,this.tank.x-cx)+this.offsetAngle*0.25;
      const gx=cx+Math.cos(ang)*120;
      const gy=cy+Math.sin(ang)*120;
      this.setGoal(gx,gy,1.0);
      return;
    }

    if(g.activeCommand==='SCATTER' || this.commandState==='SCATTER'){
      const enemyBase={x:CFG.mapWidth*CFG.tileSize-250,y:CFG.mapHeight*CFG.tileSize-250};
      const ang=Math.atan2(enemyBase.y-this.tank.y, enemyBase.x-this.tank.x) + this.offsetAngle*0.35;
      const gx=this.tank.x + Math.cos(ang)*260;
      const gy=this.tank.y + Math.sin(ang)*260;
      this.setGoal(gx,gy,0.9);
      return;
    }

    if(!this.lastGoal || this.goalHoldTimer<=0){
      const base=(this.tank.team===CFG.teams.BLUE)?{x:260,y:260}:{x:CFG.mapWidth*CFG.tileSize-260,y:CFG.mapHeight*CFG.tileSize-260};
      const ang=MathUtils.rand(-Math.PI,Math.PI);
      const r=MathUtils.rand(180,420);
      const gx=MathUtils.clamp(base.x + Math.cos(ang)*r, 60, CFG.mapWidth*CFG.tileSize-60);
      const gy=MathUtils.clamp(base.y + Math.sin(ang)*r, 60, CFG.mapHeight*CFG.tileSize-60);
      this.setGoal(gx,gy,1.0);
    }
  }

  chase(dt){
    const g=this.tank.game;
    const t=this.target;
    if(!t || t.dead || t.isWreckage){ this.state='PATROL'; this.target=null; return; }

    const d=MathUtils.dist(this.tank.x,this.tank.y,t.x,t.y);
    const canSee=this.canSee(t);

    if(canSee){
      g.markEngagement(this.tank.team, 2.6);

      const desiredDist=220;
      const ang=Math.atan2(this.tank.y-t.y, this.tank.x-t.x);
      const gx=t.x + Math.cos(ang)*desiredDist;
      const gy=t.y + Math.sin(ang)*desiredDist;

      if(d>desiredDist+50) this.setGoal(gx,gy,0.7);
      else if(d<desiredDist-60){
        const bx=t.x + Math.cos(ang)*(desiredDist+120);
        const by=t.y + Math.sin(ang)*(desiredDist+120);
        this.setGoal(bx,by,0.7);
      }else{
        this.moveDir.x=0; this.moveDir.y=0;
      }

      const aim=this.getAimAngle();
      const diff=Math.abs(MathUtils.angleDiff(aim,this.tank.angle));
      this.wantToShoot = (diff<0.24);
      return;
    }

    const flank=this.planFlank(t);
    if(flank){
      this.setGoal(flank.x, flank.y, 0.9);
      this.wantToShoot=false;
      return;
    }

    this.setGoal(t.x,t.y,0.8);
  }

  flee(dt,enemies){
    const g=this.tank.game;
    if(enemies.length===0){ this.state='PATROL'; return; }
    let closest=null, bestD=Infinity;
    for(const e of enemies){
      const d=MathUtils.dist(this.tank.x,this.tank.y,e.x,e.y);
      if(d<bestD){ bestD=d; closest=e; }
    }
    if(!closest){ this.state='PATROL'; return; }
    const ang=Math.atan2(this.tank.y-closest.y,this.tank.x-closest.x);
    const gx=this.tank.x + Math.cos(ang)*260;
    const gy=this.tank.y + Math.sin(ang)*260;
    this.setGoal(gx,gy,0.7);
    this.wantToShoot=false;
  }

  doInvestigate(dt){
    const g=this.tank.game;
    if(!this.investigatePos){ this.state='PATROL'; return; }
    const age=(Date.now()-this.investigatePos.stamp)/1000;
    if(age>6.0){ this.investigatePos=null; this.state='PATROL'; return; }
    this.setGoal(this.investigatePos.x, this.investigatePos.y, 0.8);
  }

  executeCommandLogic(dt, visible){
    const g=this.tank.game;

    if(this.commandState==="SEARCH"){
      if(this.searchTarget){
        this.setGoal(this.searchTarget.x, this.searchTarget.y, 0.8);
        if(MathUtils.dist(this.tank.x,this.tank.y,this.searchTarget.x,this.searchTarget.y)<180){
          this.moveDir.x=0; this.moveDir.y=0;
        }
        return;
      }
      if(g.searchRallyPoint && g.isTeamEngaged(this.tank.team)){
        this.setGoal(g.searchRallyPoint.x, g.searchRallyPoint.y, 0.9);
        if(MathUtils.dist(this.tank.x,this.tank.y,g.searchRallyPoint.x,g.searchRallyPoint.y)<220){
          this.moveDir.x=0; this.moveDir.y=0;
        }
        return;
      }
      this.commandState="SCATTER";
      this.state="PATROL";
      return;
    }

    if(this.commandState==='RALLY'){
      this.state='PATROL';
      this.patrol(dt);
      return;
    }
    if(this.commandState==='SCATTER'){
      this.state='PATROL';
      this.patrol(dt);
      return;
    }
    if(this.commandState==='SQUAD_SMOKE' || this.commandState==='SQUAD_EMP'){
      this.state='PATROL';
      this.patrol(dt);
      return;
    }

    this.state='PATROL';
    this.patrol(dt);
  }
}

/* ===== å­å¼¹/å¯¼å¼¹/ç‚¸å¼¹/ç‰¹æ•ˆ ===== */
class Bullet{
  constructor(game,x,y,angle,owner){
    this.game=game; this.x=x; this.y=y;
    this.vx=Math.cos(angle)*CFG.bulletSpeed;
    this.vy=Math.sin(angle)*CFG.bulletSpeed;
    this.life=CFG.bulletLife;
    this.dead=false;
    this.owner=owner;
    this.r=2.2;
  }
  update(dt){
    this.life-=dt;
    if(this.life<=0){ this.dead=true; return; }
    this.x+=this.vx*dt; this.y+=this.vy*dt;

    const tx=Math.floor(this.x/CFG.tileSize), ty=Math.floor(this.y/CFG.tileSize);
    if(this.game.map[ty] && this.game.map[ty][tx]>0){ this.dead=true; this.game.particles.push(new Particle(this.x,this.y,'#888',0.35)); return; }

    for(const t of this.game.tanks){
      if(t.team!==this.owner.team && !t.dead && !t.isWreckage){
        if(MathUtils.dist(this.x,this.y,t.x,t.y) < t.radius){
          this.dead=true;
          t.takeDamage(18, this.owner);
          AudioSys.sfxHit();
          for(let i=0;i<6;i++) this.game.particles.push(new Particle(this.x,this.y,'#f1c40f',0.35));
          return;
        }
      }
    }
  }
  draw(ctx){
    ctx.fillStyle='rgba(255,176,0,0.95)';
    ctx.fillRect(this.x-1,this.y-1,2,2);
  }
}

class AirBullet{
  constructor(game,x,y,angle,owner){
    this.game=game; this.x=x; this.y=y;
    this.vx=Math.cos(angle)*CFG.jetGunSpeed;
    this.vy=Math.sin(angle)*CFG.jetGunSpeed;
    this.life=CFG.jetGunLife;
    this.dead=false;
    this.owner=owner;
  }
  update(dt){
    this.life-=dt;
    if(this.life<=0){ this.dead=true; return; }
    this.x+=this.vx*dt; this.y+=this.vy*dt;

    for(const j of this.game.jets){
      if(j.team!==this.owner.team && !j.dead && !j.isWreckage && !j.crashing){
        if(MathUtils.dist(this.x,this.y,j.x,j.y) < j.radius*0.9){
          this.dead=true;
          j.takeDamage(12,this.owner);
          AudioSys.sfxHit();
          for(let i=0;i<6;i++) this.game.particles.push(new Particle(this.x,this.y,'#f1c40f',0.35));
          this.game.markEngagement(this.owner.team, 2.2);
          return;
        }
      }
    }
  }
  draw(ctx){
    ctx.fillStyle='rgba(74,246,38,0.9)';
    ctx.fillRect(this.x-1,this.y-1,2,2);
  }
}

class HomingMissile{
  constructor(game,x,y,angle,owner,target){
    this.game=game; this.x=x; this.y=y; this.angle=angle;
    this.owner=owner; this.target=target;
    this.life=CFG.missileLife; this.dead=false;
    this.speed=CFG.missileSpeed;
  }
  update(dt){
    this.life-=dt;
    if(this.life<=0){ this.dead=true; return; }
    if(this.target && (!this.target.dead && !this.target.isWreckage && !this.target.crashing)){
      const desired=Math.atan2(this.target.y-this.y,this.target.x-this.x);
      const diff=MathUtils.angleDiff(desired,this.angle);
      this.angle += MathUtils.clamp(diff, -CFG.missileTurn*dt, CFG.missileTurn*dt);
    }
    this.x += Math.cos(this.angle)*this.speed*dt;
    this.y += Math.sin(this.angle)*this.speed*dt;

    if(this.target && !this.target.dead && !this.target.isWreckage && !this.target.crashing){
      if(MathUtils.dist(this.x,this.y,this.target.x,this.target.y) < 22){
        this.dead=true;
        this.target.takeDamage(CFG.missileDamage, this.owner);
        AudioSys.sfxExplode();
        for(let i=0;i<18;i++) this.game.particles.push(new Particle(this.x,this.y,'#e74c3c',0.6));
        this.game.markEngagement(this.owner.team, 2.6);
      }
    }
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    ctx.fillStyle='#ffb000';
    ctx.fillRect(-6,-2,10,4);
    ctx.fillStyle='#ff3333';
    ctx.fillRect(-2,-1,3,2);
    ctx.restore();
  }
}

class Bomb{
  constructor(game,x,y,team,owner){
    this.game=game; this.x=x; this.y=y; this.team=team; this.owner=owner;
    this.t=0; this.dead=false;
  }
  update(dt){
    this.t+=dt;
    if(this.t>=CFG.bombFallTime){
      this.dead=true;
      this.explode();
    }
  }
  explode(){
    const g=this.game;
    const x=this.x,y=this.y;
    g.destroyTiles3x3(x,y);
    AudioSys.sfxExplode();
    for(let i=0;i<40;i++){
      g.particles.push(new Particle(x,y,'#e74c3c',0.9));
      if(i%2===0) g.particles.push(new Particle(x,y,'#f1c40f',0.7));
    }

    for(const t of g.tanks){
      if(t.dead||t.isWreckage) continue;
      const d=MathUtils.dist(x,y,t.x,t.y);
      if(d<CFG.bombRadius){
        let dmg=CFG.bombDamage*(1-d/CFG.bombRadius);
        if(t.team===this.team) dmg*=0.45;
        t.takeDamage(dmg, this.owner);
      }
    }
    g.markEngagement(this.team, 3.0);
    g.smokes.push(new Smoke(x,y, true));
  }
  draw(ctx){
    const blink=(Math.sin(this.t*18)>0)?1:0;
    if(blink){
      ctx.fillStyle='rgba(255,176,0,0.85)';
      ctx.fillRect(this.x-2,this.y-2,4,4);
    }
  }
}

class AAMissile{
  constructor(game, targetJet){
    this.game=game;
    this.target=targetJet;
    const edge=Math.random()<0.5? -120 : CFG.mapWidth*CFG.tileSize+120;
    const y=MathUtils.rand(80, CFG.mapHeight*CFG.tileSize-80);
    this.x=edge; this.y=y;
    this.angle=Math.atan2(targetJet.y-this.y, targetJet.x-this.x);
    this.dead=false;
    this.life=4.2;
  }
  update(dt){
    this.life-=dt;
    if(this.life<=0){ this.dead=true; return; }
    if(!this.target || this.target.dead || this.target.isWreckage){ this.dead=true; return; }
    const desired=Math.atan2(this.target.y-this.y,this.target.x-this.x);
    const diff=MathUtils.angleDiff(desired,this.angle);
    this.angle += MathUtils.clamp(diff, -CFG.aaTurn*dt, CFG.aaTurn*dt);
    this.x += Math.cos(this.angle)*CFG.aaSpeed*dt;
    this.y += Math.sin(this.angle)*CFG.aaSpeed*dt;

    if(MathUtils.dist(this.x,this.y,this.target.x,this.target.y) < 22){
      this.dead=true;
      this.target.takeDamage(999, null);
      AudioSys.sfxAa();
      for(let i=0;i<20;i++) this.game.particles.push(new Particle(this.x,this.y,'#ff3333',0.85));
    }
  }
  draw(ctx){
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    ctx.fillStyle='#ff3333';
    ctx.fillRect(-8,-2,14,4);
    ctx.fillStyle='rgba(255,255,255,0.35)';
    ctx.fillRect(-10,-1,3,2);
    ctx.restore();
  }
}

class Particle{
  constructor(x,y,color,life=0.6){
    this.x=x; this.y=y;
    this.vx=MathUtils.rand(-120,120);
    this.vy=MathUtils.rand(-120,120);
    this.life=life;
    this.color=color;
    this.size=MathUtils.rand(1.5,3.5);
    this.drag=MathUtils.rand(0.90,0.96);
  }
  update(dt){
    this.life-=dt;
    this.x+=this.vx*dt; this.y+=this.vy*dt;
    this.vx*=Math.pow(this.drag, dt*60);
    this.vy*=Math.pow(this.drag, dt*60);
    this.vy+=40*dt;
  }
  draw(ctx){
    const a=Math.max(0, Math.min(1, this.life/0.6));
    ctx.fillStyle=this.color;
    ctx.globalAlpha=a;
    ctx.fillRect(this.x-this.size/2,this.y-this.size/2,this.size,this.size);
    ctx.globalAlpha=1;
  }
}

class Shockwave{
  constructor(x,y,color){
    this.x=x; this.y=y; this.r=0; this.done=false; this.color=color;
  }
  update(dt){
    this.r += 520*dt;
    if(this.r>260) this.done=true;
  }
  draw(ctx){
    const a=Math.max(0,1-this.r/260);
    ctx.strokeStyle=this.color;
    ctx.globalAlpha=0.22*a;
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=1;
  }
}

class Smoke{
  constructor(x,y,fromExplosion=false){
    this.x=x; this.y=y;
    this.life=CFG.smokeDuration;
    this.maxLife=CFG.smokeDuration;
    this.radius=fromExplosion?120:90;
    this.maxRadius=fromExplosion?220:190;

    this.puffs=[];
    const puffCount=fromExplosion?44:34;
    for(let i=0;i<puffCount;i++){
      const a=Math.random()*Math.PI*2;
      const r=Math.random()*(this.radius*0.55);
      this.puffs.push({
        ox:Math.cos(a)*r,
        oy:Math.sin(a)*r,
        vx:MathUtils.rand(-18,18),
        vy:MathUtils.rand(-18,18),
        s:MathUtils.rand(8,18),
        n:Math.random()*10,
        a:MathUtils.rand(0.22,0.55)
      });
    }
  }
  update(dt){
    this.life-=dt;
    const t=1-(this.life/this.maxLife);
    this.radius=MathUtils.lerp(this.radius,this.maxRadius,0.08);

    for(const p of this.puffs){
      p.n += dt*1.8;
      const wobX = Noise.perlin(p.n, 0.5)*8;
      const wobY = Noise.perlin(0.5, p.n)*8;
      p.ox += (p.vx + wobX)*dt;
      p.oy += (p.vy + wobY)*dt;
      p.vx *= Math.pow(0.90, dt*60);
      p.vy *= Math.pow(0.90, dt*60);
    }
  }
  draw(ctx){
    if(this.life<=0) return;
    const a=Math.max(0, Math.min(1, this.life/this.maxLife));
    const fade = a;
    ctx.save();
    ctx.globalCompositeOperation="source-over";

    ctx.globalAlpha=0.18*fade;
    for(const p of this.puffs){
      const x=this.x+p.ox*0.95;
      const y=this.y+p.oy*0.95;
      const s=p.s*1.25;
      ctx.fillStyle='rgba(140,140,140,1)';
      ctx.fillRect(x-s/2,y-s/2,s,s);
      if(Math.random()<0.35) ctx.fillRect(x-s/2+2,y-s/2+2,s-4,s-4);
    }

    ctx.globalAlpha=0.22*fade;
    for(const p of this.puffs){
      const x=this.x+p.ox;
      const y=this.y+p.oy;
      const s=p.s;
      ctx.fillStyle='rgba(190,190,190,1)';
      ctx.fillRect(x-s/2,y-s/2,s,s);
      if(Math.random()<0.30){
        ctx.fillStyle='rgba(60,60,60,1)';
        ctx.fillRect(x-1,y-1,2,2);
      }
    }

    ctx.globalAlpha=0.12*fade;
    for(const p of this.puffs){
      const x=this.x+p.ox + MathUtils.rand(-1.2,1.2);
      const y=this.y+p.oy + MathUtils.rand(-1.2,1.2);
      const s=p.s*0.9;
      ctx.fillStyle='rgba(235,235,235,1)';
      ctx.fillRect(x-s/2,y-s/2,s,s);
    }

    ctx.globalAlpha=0.08*fade;
    ctx.strokeStyle='rgba(255,255,255,0.8)';
    ctx.lineWidth=2;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.radius*0.95,0,Math.PI*2); ctx.stroke();

    ctx.restore();
  }
}
</script>
</body>
</html>
